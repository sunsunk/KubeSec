// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package workflow

import (
	context "context"
	grpc "google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	sync "sync"
)

// Ensure, that WorkflowServiceClientMock does implement WorkflowServiceClient.
// If this is not the case, regenerate this file with moq.
var _ WorkflowServiceClient = &WorkflowServiceClientMock{}

// WorkflowServiceClientMock is a mock implementation of WorkflowServiceClient.
//
//	func TestSomethingThatUsesWorkflowServiceClient(t *testing.T) {
//
//		// make and configure a mocked WorkflowServiceClient
//		mockedWorkflowServiceClient := &WorkflowServiceClientMock{
//			GetWorkflowsFunc: func(ctx context.Context, in *GetWorkflowsRequest, opts ...grpc.CallOption) (WorkflowService_GetWorkflowsClient, error) {
//				panic("mock out the GetWorkflows method")
//			},
//			PublishEventFunc: func(ctx context.Context, in *PublishEventRequest, opts ...grpc.CallOption) (*PublishEventResponse, error) {
//				panic("mock out the PublishEvent method")
//			},
//		}
//
//		// use mockedWorkflowServiceClient in code that requires WorkflowServiceClient
//		// and then make assertions.
//
//	}
type WorkflowServiceClientMock struct {
	// GetWorkflowsFunc mocks the GetWorkflows method.
	GetWorkflowsFunc func(ctx context.Context, in *GetWorkflowsRequest, opts ...grpc.CallOption) (WorkflowService_GetWorkflowsClient, error)

	// PublishEventFunc mocks the PublishEvent method.
	PublishEventFunc func(ctx context.Context, in *PublishEventRequest, opts ...grpc.CallOption) (*PublishEventResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetWorkflows holds details about calls to the GetWorkflows method.
		GetWorkflows []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *GetWorkflowsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// PublishEvent holds details about calls to the PublishEvent method.
		PublishEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *PublishEventRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockGetWorkflows sync.RWMutex
	lockPublishEvent sync.RWMutex
}

// GetWorkflows calls GetWorkflowsFunc.
func (mock *WorkflowServiceClientMock) GetWorkflows(ctx context.Context, in *GetWorkflowsRequest, opts ...grpc.CallOption) (WorkflowService_GetWorkflowsClient, error) {
	if mock.GetWorkflowsFunc == nil {
		panic("WorkflowServiceClientMock.GetWorkflowsFunc: method is nil but WorkflowServiceClient.GetWorkflows was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *GetWorkflowsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockGetWorkflows.Lock()
	mock.calls.GetWorkflows = append(mock.calls.GetWorkflows, callInfo)
	mock.lockGetWorkflows.Unlock()
	return mock.GetWorkflowsFunc(ctx, in, opts...)
}

// GetWorkflowsCalls gets all the calls that were made to GetWorkflows.
// Check the length with:
//
//	len(mockedWorkflowServiceClient.GetWorkflowsCalls())
func (mock *WorkflowServiceClientMock) GetWorkflowsCalls() []struct {
	Ctx  context.Context
	In   *GetWorkflowsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *GetWorkflowsRequest
		Opts []grpc.CallOption
	}
	mock.lockGetWorkflows.RLock()
	calls = mock.calls.GetWorkflows
	mock.lockGetWorkflows.RUnlock()
	return calls
}

// PublishEvent calls PublishEventFunc.
func (mock *WorkflowServiceClientMock) PublishEvent(ctx context.Context, in *PublishEventRequest, opts ...grpc.CallOption) (*PublishEventResponse, error) {
	if mock.PublishEventFunc == nil {
		panic("WorkflowServiceClientMock.PublishEventFunc: method is nil but WorkflowServiceClient.PublishEvent was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *PublishEventRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPublishEvent.Lock()
	mock.calls.PublishEvent = append(mock.calls.PublishEvent, callInfo)
	mock.lockPublishEvent.Unlock()
	return mock.PublishEventFunc(ctx, in, opts...)
}

// PublishEventCalls gets all the calls that were made to PublishEvent.
// Check the length with:
//
//	len(mockedWorkflowServiceClient.PublishEventCalls())
func (mock *WorkflowServiceClientMock) PublishEventCalls() []struct {
	Ctx  context.Context
	In   *PublishEventRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *PublishEventRequest
		Opts []grpc.CallOption
	}
	mock.lockPublishEvent.RLock()
	calls = mock.calls.PublishEvent
	mock.lockPublishEvent.RUnlock()
	return calls
}

// Ensure, that WorkflowService_GetWorkflowsClientMock does implement WorkflowService_GetWorkflowsClient.
// If this is not the case, regenerate this file with moq.
var _ WorkflowService_GetWorkflowsClient = &WorkflowService_GetWorkflowsClientMock{}

// WorkflowService_GetWorkflowsClientMock is a mock implementation of WorkflowService_GetWorkflowsClient.
//
//	func TestSomethingThatUsesWorkflowService_GetWorkflowsClient(t *testing.T) {
//
//		// make and configure a mocked WorkflowService_GetWorkflowsClient
//		mockedWorkflowService_GetWorkflowsClient := &WorkflowService_GetWorkflowsClientMock{
//			CloseSendFunc: func() error {
//				panic("mock out the CloseSend method")
//			},
//			ContextFunc: func() context.Context {
//				panic("mock out the Context method")
//			},
//			HeaderFunc: func() (metadata.MD, error) {
//				panic("mock out the Header method")
//			},
//			RecvFunc: func() (*GetWorkflowsResponse, error) {
//				panic("mock out the Recv method")
//			},
//			RecvMsgFunc: func(m interface{}) error {
//				panic("mock out the RecvMsg method")
//			},
//			SendMsgFunc: func(m interface{}) error {
//				panic("mock out the SendMsg method")
//			},
//			TrailerFunc: func() metadata.MD {
//				panic("mock out the Trailer method")
//			},
//		}
//
//		// use mockedWorkflowService_GetWorkflowsClient in code that requires WorkflowService_GetWorkflowsClient
//		// and then make assertions.
//
//	}
type WorkflowService_GetWorkflowsClientMock struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (metadata.MD, error)

	// RecvFunc mocks the Recv method.
	RecvFunc func() (*GetWorkflowsResponse, error)

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m interface{}) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m interface{}) error

	// TrailerFunc mocks the Trailer method.
	TrailerFunc func() metadata.MD

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Trailer holds details about calls to the Trailer method.
		Trailer []struct {
		}
	}
	lockCloseSend sync.RWMutex
	lockContext   sync.RWMutex
	lockHeader    sync.RWMutex
	lockRecv      sync.RWMutex
	lockRecvMsg   sync.RWMutex
	lockSendMsg   sync.RWMutex
	lockTrailer   sync.RWMutex
}

// CloseSend calls CloseSendFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.CloseSendFunc: method is nil but WorkflowService_GetWorkflowsClient.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	mock.lockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.CloseSendCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCloseSend.RLock()
	calls = mock.calls.CloseSend
	mock.lockCloseSend.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.ContextFunc: method is nil but WorkflowService_GetWorkflowsClient.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.ContextCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) Header() (metadata.MD, error) {
	if mock.HeaderFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.HeaderFunc: method is nil but WorkflowService_GetWorkflowsClient.Header was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.HeaderCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) Recv() (*GetWorkflowsResponse, error) {
	if mock.RecvFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.RecvFunc: method is nil but WorkflowService_GetWorkflowsClient.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.RecvCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) RecvMsg(m interface{}) error {
	if mock.RecvMsgFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.RecvMsgFunc: method is nil but WorkflowService_GetWorkflowsClient.RecvMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.RecvMsgCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) RecvMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) SendMsg(m interface{}) error {
	if mock.SendMsgFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.SendMsgFunc: method is nil but WorkflowService_GetWorkflowsClient.SendMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.SendMsgCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) SendMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// Trailer calls TrailerFunc.
func (mock *WorkflowService_GetWorkflowsClientMock) Trailer() metadata.MD {
	if mock.TrailerFunc == nil {
		panic("WorkflowService_GetWorkflowsClientMock.TrailerFunc: method is nil but WorkflowService_GetWorkflowsClient.Trailer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrailer.Lock()
	mock.calls.Trailer = append(mock.calls.Trailer, callInfo)
	mock.lockTrailer.Unlock()
	return mock.TrailerFunc()
}

// TrailerCalls gets all the calls that were made to Trailer.
// Check the length with:
//
//	len(mockedWorkflowService_GetWorkflowsClient.TrailerCalls())
func (mock *WorkflowService_GetWorkflowsClientMock) TrailerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrailer.RLock()
	calls = mock.calls.Trailer
	mock.lockTrailer.RUnlock()
	return calls
}
