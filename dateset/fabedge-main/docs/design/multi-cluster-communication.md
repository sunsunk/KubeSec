# 多集群通信设计

## 概述

多集群通信是为了让多个异构的，分布在不同网络的集群可以相互访问彼此的节点和服务(目前仅支持集群的云端节点相互通信)

多个通信的集群中必须且只能有一个主(host)集群，其他集群是主集群的成员(member)集群, 每个成员集群在主集群注册自己需要外部通信的端点信息（目前仅限于Connector)。

集群间不能直接通信, 用户需要在主集群通过社区来组织需要通信的集群，在同一个社区的集群才能相互访问。

各个集群间的节点，Pod，服务的地址不能重复。

## 集群分类

### 按系统分类

* 常规Kubernetes集群
* 边缘计算集群(KubeEdge/OpenYurt/SuperEdge).

### 按拓扑结构分类

* 所有节点都在一个区域，网络也在一个局域网，通常是企业内部或云上的一个Kubernetes集群，运行各种服务，也可能是某种设施的小型集群。
* 管理节点在云端，边缘节点分布在多个位置，使用不同的网络. 

### 按角色分类

通信的集群可以有多个，但角色分为两类：主集群和成员集群，主集群必须且只能有一个

主集群的功能如下：

* 证书派发。所有集群的根证书存储在主机群，成员集群可以从主集群为Connector和边缘节点Agent申请证书。
* 集中存储每个集群暴露的端点信息，目前仅限于Connector
* 社区管理，需要通信的集群必须在同一社区
* 向其他集群下发需要通信的集群的端点信息

成员集群的功能如下：
* 向主集群申请本集群的端点证书
* 向主集群提供自身对外暴露的端点信息
* 通过主集群获取其他集群的端点信息，并跟其他集群建立通信

## 自定义资源

为了管理多集群间的通信，需要添加或修改一些CRD。

#### Community

Community原先用于管理一个集群内部边缘节点间的通信，现在可以用来管理需要通信的多个集群，但暂时不支持边缘节点跨集群通信。目前一个社区内的成员类型必须统一，要么是本集群的边缘节点，要么是各个集群的connector.

#### Cluster

Cluster是主集群用来记录其他集群端点信息的数据结构，有以下字段：

 * name. 集群名称，每个成员集群访问主集群时声明自己的身份。

 * token. 用于成员集群初始化，token由主集群的operator生成。

 * endpoints. 该集群内部所有需要跟其他集群通信的端点信息，其中Connector是必须上传的。
   * Name. 必须唯一，建议需要通信的集群在配置cluster domain时也保持唯一。
   * PublicAddresses. 集群用于对外通信的公网地址，该地址必须可以被其他集群和本集群的边缘节点(如果有)访问
   * Subnets. 主要是集群的PodCIDRs数据，但也含有提供集群的ServiceCIDR。
   * NodeCIDRs. 集群内部云端节点的所有节点的IP地址
   * Type. 表明端点类型： Connector和EdgeNode

   

## 名称管理

各个集群都有Connector，节点名称也可能重复，但使用社区时，需要保证成员名称唯一，为了达到这个目标，在每个集群上报本集群的端点信息时需要将名称修改一下，加上集群前缀，比如 cluster1的Connector名称要改为: cluster1.connector。

