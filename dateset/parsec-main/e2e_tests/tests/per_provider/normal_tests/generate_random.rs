// Copyright 2020 Contributors to the Parsec project.
// SPDX-License-Identifier: Apache-2.0
use e2e_tests::TestClient;
use parsec_client::core::interface::requests::{Opcode, ResponseStatus};

#[test]
fn generate_random_not_supported() {
    let mut client = TestClient::new();
    if !client.is_operation_supported(Opcode::PsaGenerateRandom) {
        assert_eq!(
            client.generate_bytes(15,).unwrap_err(),
            ResponseStatus::PsaErrorNotSupported
        );
    }
}

#[test]
fn simple_generate_random() {
    let mut client = TestClient::new();

    if !client.is_operation_supported(Opcode::PsaGenerateRandom) {
        return;
    }

    // Less than one in ~35 billion chance of collision. Should be good enough for our testing.
    const NBYTES: usize = 35;
    let random_bytes_a = client.generate_bytes(NBYTES).unwrap();
    let random_bytes_b = client.generate_bytes(NBYTES).unwrap();

    assert_eq!(random_bytes_a.len(), NBYTES);
    assert_eq!(random_bytes_b.len(), NBYTES);

    for (a, b) in random_bytes_a.iter().zip(random_bytes_b.iter()) {
        if *a != *b {
            return;
        }
    }

    panic!(
        "Two vectors of {} randomly generated bytes were equal!",
        NBYTES
    );
}

#[test]
fn generate_zero_bytes() {
    let mut client = TestClient::new();

    if !client.is_operation_supported(Opcode::PsaGenerateRandom) {
        return;
    }

    const NBYTES: usize = 0;
    let random_bytes = client.generate_bytes(NBYTES).unwrap();

    assert_eq!(random_bytes, Vec::<u8>::new());
}
