use anyhow::Result;
use kclvm_utils::path::PathPrefix;
use std::env::consts::DLL_SUFFIX;
use std::path::PathBuf;

const KCLVM_CLI_BIN_PATH_ENV_VAR: &str = "KCLVM_CLI_BIN_PATH";
const KCLVM_LIB_LINK_PATH_ENV_VAR: &str = "KCLVM_LIB_LINK_PATH";
const KCLVM_LIB_SHORT_NAME: &str = "kclvm_cli_cdylib";
const EXEC_ROOT_NOT_FOUND_MSG: &str = "Internal error: the executable root is not found";

/// KclvmLinker is mainly responsible for linking the libs generated by KclvmAssembler.
pub struct KclvmLinker;
impl KclvmLinker {
    /// Link the libs generated by method "gen_bc_or_ll_file".
    pub fn link_all_libs(lib_paths: Vec<String>, lib_path: String) -> Result<String> {
        // In the final stage of link, we can't ignore any undefined symbols and do
        // not allow external mounting of the implementation.
        Command::new()?.link_libs_with_cc(&lib_paths, &lib_path)
    }
}

#[derive(Debug)]
pub struct Command {
    executable_root: String,
}

impl Command {
    pub fn new() -> Result<Self> {
        let executable_root = Self::get_executable_root()?;

        Ok(Self { executable_root })
    }

    /// Link dynamic libraries into one library using cc-rs lib.
    pub(crate) fn link_libs_with_cc(&mut self, libs: &[String], lib_path: &str) -> Result<String> {
        let lib_suffix = Self::get_lib_suffix();
        let lib_path = if lib_path.is_empty() {
            format!("{}{}", "_a.out", lib_suffix)
        } else if !lib_path.ends_with(&lib_suffix) {
            format!("{}{}", lib_path, lib_suffix)
        } else {
            lib_path.to_string()
        };

        #[cfg(not(target_os = "windows"))]
        let target = format!("{}-{}", std::env::consts::ARCH, std::env::consts::OS);

        #[cfg(target_os = "windows")]
        let target = format!("{}-{}", std::env::consts::ARCH, Self::cc_env_windows());

        let mut build = cc::Build::new();

        build
            .cargo_metadata(false)
            .no_default_flags(false)
            .pic(true)
            .shared_flag(true)
            .opt_level(0)
            .target(&target)
            .host(&target)
            .flag("-o")
            .flag(&lib_path);

        build.files(libs);

        // Run command with cc.
        let mut cmd = build.try_get_compiler()?.to_command();
        self.add_args(libs, lib_path.to_string(), &mut cmd)?;
        let result = cmd.output()?;
        if !result.status.success() {
            anyhow::bail!(
                "run linker failed: stdout {}, stderr: {}",
                String::from_utf8_lossy(&result.stdout),
                String::from_utf8_lossy(&result.stderr)
            );
        }
        // Use absolute path.
        let path = PathBuf::from(&lib_path).canonicalize()?;
        Ok(path.adjust_canonicalization())
    }

    /// Add args for cc.
    pub(crate) fn add_args(
        &self,
        libs: &[String],
        lib_path: String,
        cmd: &mut std::process::Command,
    ) -> Result<()> {
        #[cfg(not(target_os = "windows"))]
        self.unix_args(libs, lib_path, cmd)?;

        #[cfg(target_os = "windows")]
        self.msvc_win_args(libs, lib_path, cmd)?;

        Ok(())
    }

    /// Add args for cc on unix os.
    pub(crate) fn unix_args(
        &self,
        libs: &[String],
        _lib_path: String,
        cmd: &mut std::process::Command,
    ) -> Result<()> {
        let path = self.get_lib_link_path()?;
        cmd.args(libs)
            .arg(&format!("-Wl,-rpath,{}", &path))
            .arg(&format!("-L{}", &path))
            .arg(&format!("-I{}/include", self.executable_root))
            .arg(&format!("-l{KCLVM_LIB_SHORT_NAME}"));
        Ok(())
    }

    // Add args for cc on windows os.
    #[cfg(target_os = "windows")]
    pub(crate) fn msvc_win_args(
        &self,
        libs: &[String],
        lib_path: String,
        cmd: &mut std::process::Command,
    ) -> Result<()> {
        cmd.args(libs)
            .arg(&format!("{KCLVM_LIB_SHORT_NAME}.lib"))
            .arg("/link")
            .arg("/NOENTRY")
            .arg("/NOLOGO")
            .arg(format!(r#"/LIBPATH:"{}""#, self.get_lib_link_path()?))
            .arg("/DEFAULTLIB:msvcrt.lib")
            .arg("/DEFAULTLIB:libcmt.lib")
            .arg("/DLL")
            .arg(format!("/OUT:{}", lib_path))
            .arg("/EXPORT:_kcl_run")
            .arg("/EXPORT:kclvm_main")
            .arg("/EXPORT:kclvm_plugin_init");
        Ok(())
    }

    /// Get the executable root.
    fn get_executable_root() -> Result<String> {
        if let Ok(path) = std::env::var(KCLVM_CLI_BIN_PATH_ENV_VAR) {
            return Ok(path);
        }
        let bin_name = if Self::is_windows() {
            "kclvm_cli.exe"
        } else {
            "kclvm_cli"
        };
        let p = if let Some(x) = Self::find_it(bin_name) {
            x
        } else {
            std::env::current_exe()?
        }
        .canonicalize()?;

        let err = EXEC_ROOT_NOT_FOUND_MSG;
        let p = p
            .parent()
            .ok_or(anyhow::anyhow!(err))?
            .parent()
            .ok_or(anyhow::anyhow!(err))?;
        Ok(p.to_str().ok_or(anyhow::anyhow!(err))?.to_string())
    }

    /// Get KCLVM lib link path
    pub(crate) fn get_lib_link_path(&self) -> Result<String> {
        let mut default_path = None;
        for folder in ["lib", "bin"] {
            let path = std::path::Path::new(&self.executable_root)
                .join(folder)
                .join(&Self::get_lib_name());
            if path.exists() {
                default_path = Some(
                    path.parent()
                        .ok_or(anyhow::anyhow!("{} not found", path.display()))?
                        .to_string_lossy()
                        .to_string(),
                );
                break;
            }
        }
        Ok(std::env::var(KCLVM_LIB_LINK_PATH_ENV_VAR)
            .ok()
            .or(default_path)
            .unwrap_or(self.executable_root.clone()))
    }

    /// Get KCLVM lib name
    pub(crate) fn get_lib_name() -> String {
        let suffix = Self::get_lib_suffix();
        if Self::is_windows() {
            format!("{KCLVM_LIB_SHORT_NAME}{suffix}")
        } else {
            format!("lib{KCLVM_LIB_SHORT_NAME}{suffix}")
        }
    }

    /// Specifies the filename suffix used for shared libraries on this
    /// platform. Example value is `.so`.
    ///
    /// Some possible values:
    ///
    /// - .so
    /// - .dylib
    /// - .dll
    pub(crate) fn get_lib_suffix() -> String {
        DLL_SUFFIX.to_string()
    }

    fn is_windows() -> bool {
        cfg!(target_os = "windows")
    }

    #[cfg(target_os = "windows")]
    fn cc_env_windows() -> String {
        "msvc".to_string()
    }

    fn find_it<P>(exe_name: P) -> Option<std::path::PathBuf>
    where
        P: AsRef<std::path::Path>,
    {
        std::env::var_os("PATH").and_then(|paths| {
            std::env::split_paths(&paths)
                .filter_map(|dir| {
                    let full_path = dir.join(&exe_name);
                    if full_path.is_file() {
                        Some(full_path)
                    } else {
                        None
                    }
                })
                .next()
        })
    }
}
