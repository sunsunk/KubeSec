/**
 * Generated by orval v6.12.1 🍺
 * Do not edit manually.
 * Chaos Mesh Dashboard API
 * Swagger for Chaos Mesh Dashboard. If you encounter any problems with API, please click on the issues link below to report.
 * OpenAPI spec version: 2.2
 */
import { faker } from '@faker-js/faker'
import { rest } from 'msw'

export const getDeleteArchivesMock = () => ({ status: faker.random.word() })

export const getGetArchivesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9ic0000v5difx71h6sk: faker.random.word(),
      },
      labels: {
        clfp8d9ic0001v5di1qpecewp: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getDeleteArchivesSchedulesMock = () => ({ status: faker.random.word() })

export const getGetArchivesSchedulesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesSchedulesUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesSchedulesUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9ij0002v5di52aze8xy: faker.random.word(),
      },
      labels: {
        clfp8d9ij0003v5diaz3ea0yz: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getDeleteArchivesWorkflowsMock = () => ({ status: faker.random.word() })

export const getGetArchivesWorkflowsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesWorkflowsUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9ip0004v5di8qc61pfn: faker.random.word(),
      },
      labels: {
        clfp8d9ip0005v5di2vr17qsf: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getGetCommonAnnotationsMock = () => ({
  clfp8d9iq0006v5dicd5u41dp: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getGetCommonChaosAvailableNamespacesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonConfigMock = () => ({
  burst: faker.datatype.number({ min: undefined, max: undefined }),
  cluster_mode: faker.datatype.boolean(),
  dns_server_create: faker.datatype.boolean(),
  enableFilterNamespace: faker.datatype.boolean(),
  enableProfiling: faker.datatype.boolean(),
  gcp_security_mode: faker.datatype.boolean(),
  listen_host: faker.random.word(),
  listen_port: faker.datatype.number({ min: undefined, max: undefined }),
  qps: faker.datatype.number({ min: undefined, max: undefined }),
  root_path: faker.random.word(),
  security_mode: faker.datatype.boolean(),
  target_namespace: faker.random.word(),
  version: faker.random.word(),
})

export const getGetCommonKindsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonLabelsMock = () => ({
  clfp8d9iu0007v5di75ez04ik: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getGetCommonNamespacesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonPhysicalmachineAnnotationsMock = () => ({
  clfp8d9iw0008v5di4nm7f7po: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getGetCommonPhysicalmachineLabelsMock = () => ({
  clfp8d9ix0009v5di6gu09nh2: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word()
  ),
})

export const getPostCommonPhysicalmachinesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    address: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
  }))

export const getPostCommonPodsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ip: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    state: faker.random.word(),
  }))

export const getGetCommonRbacConfigMock = () => ({
  clfp8d9j0000av5di9cbxbimk: faker.random.word(),
})

export const getGetEventsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    kind: faker.random.word(),
    message: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    object_id: faker.random.word(),
    reason: faker.random.word(),
    type: faker.random.word(),
  }))

export const getGetEventsIdMock = () => ({
  created_at: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kind: faker.random.word(),
  message: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  object_id: faker.random.word(),
  reason: faker.random.word(),
  type: faker.random.word(),
})

export const getGetEventsWorkflowUidMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    kind: faker.random.word(),
    message: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    object_id: faker.random.word(),
    reason: faker.random.word(),
    type: faker.random.word(),
  }))

export const getDeleteExperimentsMock = () => ({ status: faker.random.word() })

export const getGetExperimentsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    failed_message: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostExperimentsMock = () => ({})

export const getDeleteExperimentsUidMock = () => ({ status: faker.random.word() })

export const getGetExperimentsUidMock = () => ({
  created_at: faker.random.word(),
  failed_message: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9j5000bv5diaxnh4d8y: faker.random.word(),
      },
      labels: {
        clfp8d9j5000cv5digyqv64qk: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  uid: faker.random.word(),
})

export const getPutExperimentsPauseUidMock = () => ({ status: faker.random.word() })

export const getPutExperimentsStartUidMock = () => ({ status: faker.random.word() })

export const getGetExperimentsStateMock = () => ({
  deleting: faker.datatype.number({ min: undefined, max: undefined }),
  finished: faker.datatype.number({ min: undefined, max: undefined }),
  injecting: faker.datatype.number({ min: undefined, max: undefined }),
  paused: faker.datatype.number({ min: undefined, max: undefined }),
  running: faker.datatype.number({ min: undefined, max: undefined }),
})

export const getDeleteSchedulesMock = () => ({ status: faker.random.word() })

export const getGetSchedulesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostSchedulesMock = () => ({
  annotations: {
    clfp8d9j8000dv5di3r462nhf: faker.random.word(),
  },
  apiVersion: faker.random.word(),
  creationTimestamp: faker.random.word(),
  deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
  deletionTimestamp: faker.random.word(),
  finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word()
  ),
  generateName: faker.random.word(),
  generation: faker.datatype.number({ min: undefined, max: undefined }),
  kind: faker.random.word(),
  labels: {
    clfp8d9j9000ev5di4hwq5gga: faker.random.word(),
  },
  managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    apiVersion: faker.random.word(),
    fieldsType: faker.random.word(),
    fieldsV1: {},
    manager: faker.random.word(),
    operation: faker.random.word(),
    subresource: faker.random.word(),
    time: faker.random.word(),
  })),
  name: faker.random.word(),
  namespace: faker.random.word(),
  ownerReferences: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    apiVersion: faker.random.word(),
    blockOwnerDeletion: faker.datatype.boolean(),
    controller: faker.datatype.boolean(),
    kind: faker.random.word(),
    name: faker.random.word(),
    uid: faker.random.word(),
  })),
  resourceVersion: faker.random.word(),
  selfLink: faker.random.word(),
  spec: {
    awsChaos: {
      action: faker.random.word(),
      awsRegion: faker.random.word(),
      deviceName: faker.random.word(),
      duration: faker.random.word(),
      ec2Instance: faker.random.word(),
      endpoint: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      volumeID: faker.random.word(),
    },
    azureChaos: {
      action: faker.random.word(),
      diskName: faker.random.word(),
      duration: faker.random.word(),
      lun: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      resourceGroupName: faker.random.word(),
      secretName: faker.random.word(),
      subscriptionID: faker.random.word(),
      vmName: faker.random.word(),
    },
    blockChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9j9000fv5di2b9tggja: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9j9000gv5di86zk7inc: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9j9000hv5dic6g0gz63: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9j9000iv5di6o26cvtm: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9j9000jv5diblvo8sa4: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumeName: faker.random.word(),
    },
    concurrencyPolicy: faker.random.word(),
    dnsChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9j9000kv5di955t1d6j: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9j9000lv5di3v0v374z: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9j9000mv5didk4q59ol: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9j9000nv5di4kg38a86: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9j9000ov5di3qlx6reh: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    gcpChaos: {
      action: faker.random.word(),
      deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      instance: faker.random.word(),
      project: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      zone: faker.random.word(),
    },
    historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
    httpChaos: {
      abort: faker.datatype.boolean(),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      delay: faker.random.word(),
      duration: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      patch: {
        body: { type: faker.random.word(), value: faker.random.word() },
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
        queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
      },
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      replace: {
        body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        code: faker.datatype.number({ min: undefined, max: undefined }),
        headers: {
          clfp8d9j9000pv5di2r13gnr0: faker.random.word(),
        },
        method: faker.random.word(),
        path: faker.random.word(),
        queries: {
          clfp8d9j9000qv5di01wm5c1v: faker.random.word(),
        },
      },
      request_headers: {
        clfp8d9j9000rv5die4b6h53b: faker.random.word(),
      },
      response_headers: {
        clfp8d9j9000sv5dibxr865x9: faker.random.word(),
      },
      selector: {
        annotationSelectors: {
          clfp8d9j9000tv5di65bc7uc5: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9j9000uv5dih8wo6io2: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9j9000vv5di5azn1bv3: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9j9000wv5di1urx2s4m: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9j9000xv5di3hp47pdc: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: faker.random.word(),
      tls: {
        caName: faker.random.word(),
        certName: faker.random.word(),
        keyName: faker.random.word(),
        secretName: faker.random.word(),
        secretNamespace: faker.random.word(),
      },
      value: faker.random.word(),
    },
    ioChaos: {
      action: faker.random.word(),
      attr: {
        atime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        blocks: faker.datatype.number({ min: undefined, max: undefined }),
        ctime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        gid: faker.datatype.number({ min: undefined, max: undefined }),
        ino: faker.datatype.number({ min: undefined, max: undefined }),
        kind: faker.random.word(),
        mtime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        nlink: faker.datatype.number({ min: undefined, max: undefined }),
        perm: faker.datatype.number({ min: undefined, max: undefined }),
        rdev: faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.datatype.number({ min: undefined, max: undefined }),
        uid: faker.datatype.number({ min: undefined, max: undefined }),
      },
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: faker.random.word(),
      duration: faker.random.word(),
      errno: faker.datatype.number({ min: undefined, max: undefined }),
      methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      mistake: {
        filling: faker.random.word(),
        maxLength: faker.datatype.number({ min: undefined, max: undefined }),
        maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      path: faker.random.word(),
      percent: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9ja000yv5di5ina9m3z: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9ja000zv5dig3lg8oxv: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9ja0010v5diam1847ud: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9ja0011v5di298t3ucp: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9ja0012v5dih825cbo9: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumePath: faker.random.word(),
    },
    jvmChaos: {
      action: faker.random.word(),
      class: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
      database: faker.random.word(),
      duration: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      memType: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      mysqlConnectorVersion: faker.random.word(),
      name: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      ruleData: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9ja0013v5dibydk8ieq: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9ja0014v5di9wab7et4: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9ja0015v5di4w1h9137: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9ja0016v5di1ijhalvl: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9ja0017v5dif4sx8oq3: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      sqlType: faker.random.word(),
      table: faker.random.word(),
      value: faker.random.word(),
    },
    kernelChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      failKernRequest: {
        callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          funcname: faker.random.word(),
          parameters: faker.random.word(),
          predicate: faker.random.word(),
        })),
        failtype: faker.datatype.number({ min: undefined, max: undefined }),
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        probability: faker.datatype.number({ min: undefined, max: undefined }),
        times: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9ja0018v5di8ifg11d4: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9ja0019v5dihknx1x25: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9ja001av5di4fh53kbo: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9ja001bv5dihq2pe4i7: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9ja001cv5difw4sef7u: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    networkChaos: {
      action: faker.random.word(),
      bandwidth: {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
      delay: {
        correlation: faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        reorder: {
          correlation: faker.random.word(),
          gap: faker.datatype.number({ min: undefined, max: undefined }),
          reorder: faker.random.word(),
        },
      },
      device: faker.random.word(),
      direction: faker.random.word(),
      duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
      duration: faker.random.word(),
      externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      loss: { correlation: faker.random.word(), loss: faker.random.word() },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9ja001dv5di0oyado2q: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9ja001ev5di6bizc71q: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9ja001fv5dig35n3a5q: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9ja001gv5dihd445k5o: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9ja001hv5dihksig367: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: {
        mode: faker.random.word(),
        selector: {
          annotationSelectors: {
            clfp8d9ja001iv5di6voegp30: faker.random.word(),
          },
          fieldSelectors: {
            clfp8d9ja001jv5difklv01ir: faker.random.word(),
          },
          labelSelectors: {
            clfp8d9ja001kv5di8ere02cp: faker.random.word(),
          },
          namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          nodeSelectors: {
            clfp8d9ja001lv5di934e1sze: faker.random.word(),
          },
          nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => faker.random.word()
          ),
          pods: {
            clfp8d9ja001mv5didx1jb4yg: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.random.word()),
          },
        },
        value: faker.random.word(),
      },
      targetDevice: faker.random.word(),
      value: faker.random.word(),
    },
    physicalmachineChaos: {
      action: faker.random.word(),
      address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      clock: {
        'clock-ids-slice': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        'time-offset': faker.random.word(),
      },
      'disk-fill': {
        'fill-by-fallocate': faker.datatype.boolean(),
        path: faker.random.word(),
        size: faker.random.word(),
      },
      'disk-read-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      'disk-write-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      duration: faker.random.word(),
      'file-append': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        data: faker.random.word(),
        'file-name': faker.random.word(),
      },
      'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-modify': {
        'file-name': faker.random.word(),
        privilege: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
      'file-replace': {
        'dest-string': faker.random.word(),
        'file-name': faker.random.word(),
        line: faker.datatype.number({ min: undefined, max: undefined }),
        'origin-string': faker.random.word(),
      },
      'http-abort': {
        code: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-config': { file_path: faker.random.word() },
      'http-delay': {
        code: faker.random.word(),
        delay: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-request': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        'enable-conn-pool': faker.datatype.boolean(),
        url: faker.random.word(),
      },
      'jvm-exception': {
        class: faker.random.word(),
        exception: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-gc': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-latency': {
        class: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-mysql': {
        database: faker.random.word(),
        exception: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        mysqlConnectorVersion: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        sqlType: faker.random.word(),
        table: faker.random.word(),
      },
      'jvm-return': {
        class: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        value: faker.random.word(),
      },
      'jvm-rule-data': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        'rule-data': faker.random.word(),
      },
      'jvm-stress': {
        'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
        'mem-type': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'kafka-fill': {
        host: faker.random.word(),
        maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        reloadCommand: faker.random.word(),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-flood': {
        host: faker.random.word(),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        threads: faker.datatype.number({ min: undefined, max: undefined }),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-io': {
        configFile: faker.random.word(),
        nonReadable: faker.datatype.boolean(),
        nonWritable: faker.datatype.boolean(),
        topic: faker.random.word(),
      },
      mode: faker.random.word(),
      'network-bandwidth': {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        device: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      'network-corrupt': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-delay': {
        'accept-tcp-flags': faker.random.word(),
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-dns': {
        'dns-domain-name': faker.random.word(),
        'dns-ip': faker.random.word(),
        'dns-server': faker.random.word(),
      },
      'network-down': { device: faker.random.word(), duration: faker.random.word() },
      'network-duplicate': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-flood': {
        duration: faker.random.word(),
        'ip-address': faker.random.word(),
        parallel: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.random.word(),
        rate: faker.random.word(),
      },
      'network-loss': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-partition': {
        'accept-tcp-flags': faker.random.word(),
        device: faker.random.word(),
        direction: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
      },
      process: {
        process: faker.random.word(),
        recoverCmd: faker.random.word(),
        signal: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-cacheLimit': {
        addr: faker.random.word(),
        cacheSize: faker.random.word(),
        password: faker.random.word(),
        percent: faker.random.word(),
      },
      'redis-expiration': {
        addr: faker.random.word(),
        expiration: faker.random.word(),
        key: faker.random.word(),
        option: faker.random.word(),
        password: faker.random.word(),
      },
      'redis-penetration': {
        addr: faker.random.word(),
        password: faker.random.word(),
        requestNum: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-restart': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      'redis-stop': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jb001nv5di69wwa6o6: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jb001ov5di6oo6bwrj: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jb001pv5dihgl8e71j: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        physicalMachines: {
          clfp8d9jb001qv5di99o85btd: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      'stress-cpu': {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'stress-mem': {
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        size: faker.random.word(),
      },
      user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
      value: faker.random.word(),
      vm: { 'vm-name': faker.random.word() },
    },
    podChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jc001rv5di2l6vbtto: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jc001sv5di312kgvch: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jc001tv5di2y9tab5l: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jc001uv5digjts8kdr: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jc001vv5di8vh4br8r: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    schedule: faker.random.word(),
    startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    stressChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jc001wv5digsmnc3tg: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jc001xv5dibnigf9ci: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jc001yv5di8e1rbl20: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jc001zv5di2kpt4eaj: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jc0020v5di83byaza8: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      stressngStressors: faker.random.word(),
      stressors: {
        cpu: {
          load: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
        memory: {
          oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          size: faker.random.word(),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
      },
      value: faker.random.word(),
    },
    timeChaos: {
      clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jc0021v5di6wqu46dw: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jc0022v5di2with2su: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jc0023v5di7k7j2qs7: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jc0024v5di09sr0mmo: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jc0025v5diaqwp2exz: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      timeOffset: faker.random.word(),
      value: faker.random.word(),
    },
    type: faker.random.word(),
    workflow: {
      entry: faker.random.word(),
      templates: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        abortWithStatusCheck: faker.datatype.boolean(),
        awsChaos: {
          action: faker.random.word(),
          awsRegion: faker.random.word(),
          deviceName: faker.random.word(),
          duration: faker.random.word(),
          ec2Instance: faker.random.word(),
          endpoint: faker.random.word(),
          remoteCluster: faker.random.word(),
          secretName: faker.random.word(),
          volumeID: faker.random.word(),
        },
        azureChaos: {
          action: faker.random.word(),
          diskName: faker.random.word(),
          duration: faker.random.word(),
          lun: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          resourceGroupName: faker.random.word(),
          secretName: faker.random.word(),
          subscriptionID: faker.random.word(),
          vmName: faker.random.word(),
        },
        blockChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jc0026v5di8hg1gb2k: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jc0027v5dietcw8to6: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jc0028v5did9pn4k5t: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jc0029v5dia2voaoxd: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jc002av5di5tud8tm0: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
          volumeName: faker.random.word(),
        },
        children: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        conditionalBranches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({ expression: faker.random.word(), target: faker.random.word() })
        ),
        deadline: faker.random.word(),
        dnsChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jc002bv5diervv3iz8: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jc002cv5di23iv36o8: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jc002dv5di5l3d33qk: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jc002ev5di06bt7z1p: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jc002fv5did7p1eqag: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        gcpChaos: {
          action: faker.random.word(),
          deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          instance: faker.random.word(),
          project: faker.random.word(),
          remoteCluster: faker.random.word(),
          secretName: faker.random.word(),
          zone: faker.random.word(),
        },
        httpChaos: {
          abort: faker.datatype.boolean(),
          code: faker.datatype.number({ min: undefined, max: undefined }),
          delay: faker.random.word(),
          duration: faker.random.word(),
          method: faker.random.word(),
          mode: faker.random.word(),
          patch: {
            body: { type: faker.random.word(), value: faker.random.word() },
            headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              )
            ),
            queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              )
            ),
          },
          path: faker.random.word(),
          port: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          replace: {
            body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined })
            ),
            code: faker.datatype.number({ min: undefined, max: undefined }),
            headers: {
              clfp8d9jc002gv5di8um14lww: faker.random.word(),
            },
            method: faker.random.word(),
            path: faker.random.word(),
            queries: {
              clfp8d9jc002hv5dibvzf8pj1: faker.random.word(),
            },
          },
          request_headers: {
            clfp8d9jc002iv5di8x1i0feq: faker.random.word(),
          },
          response_headers: {
            clfp8d9jc002jv5di1h5h36ej: faker.random.word(),
          },
          selector: {
            annotationSelectors: {
              clfp8d9jc002kv5di474a09rk: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jc002lv5dig9fkaiye: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jc002mv5diaet672nc: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jc002nv5di8fow3691: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jd002ov5di2e2q71i1: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          target: faker.random.word(),
          tls: {
            caName: faker.random.word(),
            certName: faker.random.word(),
            keyName: faker.random.word(),
            secretName: faker.random.word(),
            secretNamespace: faker.random.word(),
          },
          value: faker.random.word(),
        },
        ioChaos: {
          action: faker.random.word(),
          attr: {
            atime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            blocks: faker.datatype.number({ min: undefined, max: undefined }),
            ctime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            gid: faker.datatype.number({ min: undefined, max: undefined }),
            ino: faker.datatype.number({ min: undefined, max: undefined }),
            kind: faker.random.word(),
            mtime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            nlink: faker.datatype.number({ min: undefined, max: undefined }),
            perm: faker.datatype.number({ min: undefined, max: undefined }),
            rdev: faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.datatype.number({ min: undefined, max: undefined }),
            uid: faker.datatype.number({ min: undefined, max: undefined }),
          },
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          delay: faker.random.word(),
          duration: faker.random.word(),
          errno: faker.datatype.number({ min: undefined, max: undefined }),
          methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          mistake: {
            filling: faker.random.word(),
            maxLength: faker.datatype.number({ min: undefined, max: undefined }),
            maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
          },
          mode: faker.random.word(),
          path: faker.random.word(),
          percent: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jd002pv5di5s8h4po0: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jd002qv5dianlwhuzs: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jd002rv5di19u15trb: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jd002sv5di1p9v47zw: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jd002tv5di3k0116lh: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
          volumePath: faker.random.word(),
        },
        jvmChaos: {
          action: faker.random.word(),
          class: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
          database: faker.random.word(),
          duration: faker.random.word(),
          exception: faker.random.word(),
          latency: faker.datatype.number({ min: undefined, max: undefined }),
          memType: faker.random.word(),
          method: faker.random.word(),
          mode: faker.random.word(),
          mysqlConnectorVersion: faker.random.word(),
          name: faker.random.word(),
          pid: faker.datatype.number({ min: undefined, max: undefined }),
          port: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          ruleData: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jd002uv5di5qe6hkp8: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jd002vv5diew3d807o: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jd002wv5di4yc8gwp6: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jd002xv5di80m54mp1: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jd002yv5dihpeqe3od: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          sqlType: faker.random.word(),
          table: faker.random.word(),
          value: faker.random.word(),
        },
        kernelChaos: {
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          failKernRequest: {
            callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              funcname: faker.random.word(),
              parameters: faker.random.word(),
              predicate: faker.random.word(),
            })),
            failtype: faker.datatype.number({ min: undefined, max: undefined }),
            headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            probability: faker.datatype.number({ min: undefined, max: undefined }),
            times: faker.datatype.number({ min: undefined, max: undefined }),
          },
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jd002zv5didj4jc0et: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jd0030v5di74ez3rr2: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jd0031v5di4be66s3n: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jd0032v5di9ak42gu9: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jd0033v5di8a1uhxyt: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        name: faker.random.word(),
        networkChaos: {
          action: faker.random.word(),
          bandwidth: {
            buffer: faker.datatype.number({ min: undefined, max: undefined }),
            limit: faker.datatype.number({ min: undefined, max: undefined }),
            minburst: faker.datatype.number({ min: undefined, max: undefined }),
            peakrate: faker.datatype.number({ min: undefined, max: undefined }),
            rate: faker.random.word(),
          },
          corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
          delay: {
            correlation: faker.random.word(),
            jitter: faker.random.word(),
            latency: faker.random.word(),
            reorder: {
              correlation: faker.random.word(),
              gap: faker.datatype.number({ min: undefined, max: undefined }),
              reorder: faker.random.word(),
            },
          },
          device: faker.random.word(),
          direction: faker.random.word(),
          duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
          duration: faker.random.word(),
          externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          loss: { correlation: faker.random.word(), loss: faker.random.word() },
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jd0034v5di4oa6b11b: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jd0035v5didujqew6t: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jd0036v5difbsd90yc: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jd0037v5di1idrg4uj: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jd0038v5did8jphwar: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          target: {
            mode: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jd0039v5di4hck5pbo: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jd003av5die00sglia: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jd003bv5die7md4mzj: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jd003cv5di0uf3153n: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jd003dv5difcpkadpr: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          targetDevice: faker.random.word(),
          value: faker.random.word(),
        },
        physicalmachineChaos: {
          action: faker.random.word(),
          address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          clock: {
            'clock-ids-slice': faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            'time-offset': faker.random.word(),
          },
          'disk-fill': {
            'fill-by-fallocate': faker.datatype.boolean(),
            path: faker.random.word(),
            size: faker.random.word(),
          },
          'disk-read-payload': {
            path: faker.random.word(),
            'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.random.word(),
          },
          'disk-write-payload': {
            path: faker.random.word(),
            'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.random.word(),
          },
          duration: faker.random.word(),
          'file-append': {
            count: faker.datatype.number({ min: undefined, max: undefined }),
            data: faker.random.word(),
            'file-name': faker.random.word(),
          },
          'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
          'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
          'file-modify': {
            'file-name': faker.random.word(),
            privilege: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
          'file-replace': {
            'dest-string': faker.random.word(),
            'file-name': faker.random.word(),
            line: faker.datatype.number({ min: undefined, max: undefined }),
            'origin-string': faker.random.word(),
          },
          'http-abort': {
            code: faker.random.word(),
            method: faker.random.word(),
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined })
            ),
            target: faker.random.word(),
          },
          'http-config': { file_path: faker.random.word() },
          'http-delay': {
            code: faker.random.word(),
            delay: faker.random.word(),
            method: faker.random.word(),
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined })
            ),
            target: faker.random.word(),
          },
          'http-request': {
            count: faker.datatype.number({ min: undefined, max: undefined }),
            'enable-conn-pool': faker.datatype.boolean(),
            url: faker.random.word(),
          },
          'jvm-exception': {
            class: faker.random.word(),
            exception: faker.random.word(),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-gc': {
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-latency': {
            class: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-mysql': {
            database: faker.random.word(),
            exception: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            mysqlConnectorVersion: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            sqlType: faker.random.word(),
            table: faker.random.word(),
          },
          'jvm-return': {
            class: faker.random.word(),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            value: faker.random.word(),
          },
          'jvm-rule-data': {
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            'rule-data': faker.random.word(),
          },
          'jvm-stress': {
            'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
            'mem-type': faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'kafka-fill': {
            host: faker.random.word(),
            maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
            messageSize: faker.datatype.number({ min: undefined, max: undefined }),
            password: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            reloadCommand: faker.random.word(),
            topic: faker.random.word(),
            username: faker.random.word(),
          },
          'kafka-flood': {
            host: faker.random.word(),
            messageSize: faker.datatype.number({ min: undefined, max: undefined }),
            password: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            threads: faker.datatype.number({ min: undefined, max: undefined }),
            topic: faker.random.word(),
            username: faker.random.word(),
          },
          'kafka-io': {
            configFile: faker.random.word(),
            nonReadable: faker.datatype.boolean(),
            nonWritable: faker.datatype.boolean(),
            topic: faker.random.word(),
          },
          mode: faker.random.word(),
          'network-bandwidth': {
            buffer: faker.datatype.number({ min: undefined, max: undefined }),
            device: faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            limit: faker.datatype.number({ min: undefined, max: undefined }),
            minburst: faker.datatype.number({ min: undefined, max: undefined }),
            peakrate: faker.datatype.number({ min: undefined, max: undefined }),
            rate: faker.random.word(),
          },
          'network-corrupt': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-delay': {
            'accept-tcp-flags': faker.random.word(),
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            jitter: faker.random.word(),
            latency: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-dns': {
            'dns-domain-name': faker.random.word(),
            'dns-ip': faker.random.word(),
            'dns-server': faker.random.word(),
          },
          'network-down': { device: faker.random.word(), duration: faker.random.word() },
          'network-duplicate': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-flood': {
            duration: faker.random.word(),
            'ip-address': faker.random.word(),
            parallel: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.random.word(),
            rate: faker.random.word(),
          },
          'network-loss': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-partition': {
            'accept-tcp-flags': faker.random.word(),
            device: faker.random.word(),
            direction: faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
          },
          process: {
            process: faker.random.word(),
            recoverCmd: faker.random.word(),
            signal: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'redis-cacheLimit': {
            addr: faker.random.word(),
            cacheSize: faker.random.word(),
            password: faker.random.word(),
            percent: faker.random.word(),
          },
          'redis-expiration': {
            addr: faker.random.word(),
            expiration: faker.random.word(),
            key: faker.random.word(),
            option: faker.random.word(),
            password: faker.random.word(),
          },
          'redis-penetration': {
            addr: faker.random.word(),
            password: faker.random.word(),
            requestNum: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'redis-restart': {
            addr: faker.random.word(),
            conf: faker.random.word(),
            flushConfig: faker.datatype.boolean(),
            password: faker.random.word(),
            redisPath: faker.datatype.boolean(),
          },
          'redis-stop': {
            addr: faker.random.word(),
            conf: faker.random.word(),
            flushConfig: faker.datatype.boolean(),
            password: faker.random.word(),
            redisPath: faker.datatype.boolean(),
          },
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9je003ev5di9daph5q3: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9je003fv5difs6wb6zg: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9je003gv5dibj6wdcaw: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            physicalMachines: {
              clfp8d9je003hv5di6mlc4bew: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          'stress-cpu': {
            load: faker.datatype.number({ min: undefined, max: undefined }),
            options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            workers: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'stress-mem': {
            options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            size: faker.random.word(),
          },
          user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
          value: faker.random.word(),
          vm: { 'vm-name': faker.random.word() },
        },
        podChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9je003iv5diafxuhrgj: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9je003jv5diay78brl1: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9je003kv5dic5pvhowk: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9je003lv5di8otr4cyn: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9je003mv5dich0b9rui: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        schedule: {
          awsChaos: {
            action: faker.random.word(),
            awsRegion: faker.random.word(),
            deviceName: faker.random.word(),
            duration: faker.random.word(),
            ec2Instance: faker.random.word(),
            endpoint: faker.random.word(),
            remoteCluster: faker.random.word(),
            secretName: faker.random.word(),
            volumeID: faker.random.word(),
          },
          azureChaos: {
            action: faker.random.word(),
            diskName: faker.random.word(),
            duration: faker.random.word(),
            lun: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            resourceGroupName: faker.random.word(),
            secretName: faker.random.word(),
            subscriptionID: faker.random.word(),
            vmName: faker.random.word(),
          },
          blockChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9je003nv5die2708di9: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9je003ov5di8q296vx8: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9je003pv5dih6u2509n: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9je003qv5di9spb11fd: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jf003rv5di39m48we2: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
            volumeName: faker.random.word(),
          },
          concurrencyPolicy: faker.random.word(),
          dnsChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jf003sv5dicvmbfsaf: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jf003tv5dibaro3f0u: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jf003uv5di2k5n1we1: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jf003vv5di4ro59lzq: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jf003wv5dib81harok: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          gcpChaos: {
            action: faker.random.word(),
            deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            duration: faker.random.word(),
            instance: faker.random.word(),
            project: faker.random.word(),
            remoteCluster: faker.random.word(),
            secretName: faker.random.word(),
            zone: faker.random.word(),
          },
          historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
          httpChaos: {
            abort: faker.datatype.boolean(),
            code: faker.datatype.number({ min: undefined, max: undefined }),
            delay: faker.random.word(),
            duration: faker.random.word(),
            method: faker.random.word(),
            mode: faker.random.word(),
            patch: {
              body: { type: faker.random.word(), value: faker.random.word() },
              headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                )
              ),
              queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                )
              ),
            },
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            replace: {
              body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined })
              ),
              code: faker.datatype.number({ min: undefined, max: undefined }),
              headers: {
                clfp8d9jf003xv5di7dwvbhb5: faker.random.word(),
              },
              method: faker.random.word(),
              path: faker.random.word(),
              queries: {
                clfp8d9jf003yv5di5fu34d1t: faker.random.word(),
              },
            },
            request_headers: {
              clfp8d9jf003zv5di35cw22wl: faker.random.word(),
            },
            response_headers: {
              clfp8d9jf0040v5difjvf1hqb: faker.random.word(),
            },
            selector: {
              annotationSelectors: {
                clfp8d9jf0041v5di9b7s9zmo: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jf0042v5di3zpzfvq3: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jf0043v5digs50enqm: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jf0044v5didzlwh1wt: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jf0045v5difkz0bbx1: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            target: faker.random.word(),
            tls: {
              caName: faker.random.word(),
              certName: faker.random.word(),
              keyName: faker.random.word(),
              secretName: faker.random.word(),
              secretNamespace: faker.random.word(),
            },
            value: faker.random.word(),
          },
          ioChaos: {
            action: faker.random.word(),
            attr: {
              atime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              blocks: faker.datatype.number({ min: undefined, max: undefined }),
              ctime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              gid: faker.datatype.number({ min: undefined, max: undefined }),
              ino: faker.datatype.number({ min: undefined, max: undefined }),
              kind: faker.random.word(),
              mtime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              nlink: faker.datatype.number({ min: undefined, max: undefined }),
              perm: faker.datatype.number({ min: undefined, max: undefined }),
              rdev: faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.datatype.number({ min: undefined, max: undefined }),
              uid: faker.datatype.number({ min: undefined, max: undefined }),
            },
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            delay: faker.random.word(),
            duration: faker.random.word(),
            errno: faker.datatype.number({ min: undefined, max: undefined }),
            methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            mistake: {
              filling: faker.random.word(),
              maxLength: faker.datatype.number({ min: undefined, max: undefined }),
              maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
            },
            mode: faker.random.word(),
            path: faker.random.word(),
            percent: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jf0046v5di2jhrd03l: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jf0047v5dibyv2f376: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jf0048v5didmlxcid9: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jf0049v5di0dlpd0sq: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jf004av5di31s2b2d6: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
            volumePath: faker.random.word(),
          },
          jvmChaos: {
            action: faker.random.word(),
            class: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
            database: faker.random.word(),
            duration: faker.random.word(),
            exception: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            memType: faker.random.word(),
            method: faker.random.word(),
            mode: faker.random.word(),
            mysqlConnectorVersion: faker.random.word(),
            name: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            ruleData: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jf004bv5di0uw4hbce: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jf004cv5di5gd88h0n: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jf004dv5di70cr3aac: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jf004ev5dicz5qboq6: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jf004fv5difybobwrb: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            sqlType: faker.random.word(),
            table: faker.random.word(),
            value: faker.random.word(),
          },
          kernelChaos: {
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            failKernRequest: {
              callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  funcname: faker.random.word(),
                  parameters: faker.random.word(),
                  predicate: faker.random.word(),
                })
              ),
              failtype: faker.datatype.number({ min: undefined, max: undefined }),
              headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              probability: faker.datatype.number({ min: undefined, max: undefined }),
              times: faker.datatype.number({ min: undefined, max: undefined }),
            },
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jf004gv5di9dvoa3q0: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jf004hv5dibw257rsz: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jf004iv5dihgki49mm: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jf004jv5di5cp8dxwy: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jf004kv5di0hil0dcm: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          networkChaos: {
            action: faker.random.word(),
            bandwidth: {
              buffer: faker.datatype.number({ min: undefined, max: undefined }),
              limit: faker.datatype.number({ min: undefined, max: undefined }),
              minburst: faker.datatype.number({ min: undefined, max: undefined }),
              peakrate: faker.datatype.number({ min: undefined, max: undefined }),
              rate: faker.random.word(),
            },
            corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
            delay: {
              correlation: faker.random.word(),
              jitter: faker.random.word(),
              latency: faker.random.word(),
              reorder: {
                correlation: faker.random.word(),
                gap: faker.datatype.number({ min: undefined, max: undefined }),
                reorder: faker.random.word(),
              },
            },
            device: faker.random.word(),
            direction: faker.random.word(),
            duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
            duration: faker.random.word(),
            externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            loss: { correlation: faker.random.word(), loss: faker.random.word() },
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jf004lv5dicmso1r45: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jf004mv5diheacc7dj: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jf004nv5didcvzc5h9: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jg004ov5diajjnhxfe: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jg004pv5di8zcq0w7v: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            target: {
              mode: faker.random.word(),
              selector: {
                annotationSelectors: {
                  clfp8d9jg004qv5di6fazgy4b: faker.random.word(),
                },
                fieldSelectors: {
                  clfp8d9jg004rv5diepcf2ct3: faker.random.word(),
                },
                labelSelectors: {
                  clfp8d9jg004sv5di9mlo2lmw: faker.random.word(),
                },
                namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.random.word()
                ),
                nodeSelectors: {
                  clfp8d9jg004tv5dihx4hdn4t: faker.random.word(),
                },
                nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                podPhaseSelectors: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
                pods: {
                  clfp8d9jg004uv5diaf8thqty: Array.from(
                    { length: faker.datatype.number({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.random.word()),
                },
              },
              value: faker.random.word(),
            },
            targetDevice: faker.random.word(),
            value: faker.random.word(),
          },
          physicalmachineChaos: {
            action: faker.random.word(),
            address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            clock: {
              'clock-ids-slice': faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              'time-offset': faker.random.word(),
            },
            'disk-fill': {
              'fill-by-fallocate': faker.datatype.boolean(),
              path: faker.random.word(),
              size: faker.random.word(),
            },
            'disk-read-payload': {
              path: faker.random.word(),
              'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.random.word(),
            },
            'disk-write-payload': {
              path: faker.random.word(),
              'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.random.word(),
            },
            duration: faker.random.word(),
            'file-append': {
              count: faker.datatype.number({ min: undefined, max: undefined }),
              data: faker.random.word(),
              'file-name': faker.random.word(),
            },
            'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
            'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
            'file-modify': {
              'file-name': faker.random.word(),
              privilege: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
            'file-replace': {
              'dest-string': faker.random.word(),
              'file-name': faker.random.word(),
              line: faker.datatype.number({ min: undefined, max: undefined }),
              'origin-string': faker.random.word(),
            },
            'http-abort': {
              code: faker.random.word(),
              method: faker.random.word(),
              path: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined })
              ),
              target: faker.random.word(),
            },
            'http-config': { file_path: faker.random.word() },
            'http-delay': {
              code: faker.random.word(),
              delay: faker.random.word(),
              method: faker.random.word(),
              path: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined })
              ),
              target: faker.random.word(),
            },
            'http-request': {
              count: faker.datatype.number({ min: undefined, max: undefined }),
              'enable-conn-pool': faker.datatype.boolean(),
              url: faker.random.word(),
            },
            'jvm-exception': {
              class: faker.random.word(),
              exception: faker.random.word(),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-gc': {
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-latency': {
              class: faker.random.word(),
              latency: faker.datatype.number({ min: undefined, max: undefined }),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-mysql': {
              database: faker.random.word(),
              exception: faker.random.word(),
              latency: faker.datatype.number({ min: undefined, max: undefined }),
              mysqlConnectorVersion: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              sqlType: faker.random.word(),
              table: faker.random.word(),
            },
            'jvm-return': {
              class: faker.random.word(),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              value: faker.random.word(),
            },
            'jvm-rule-data': {
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              'rule-data': faker.random.word(),
            },
            'jvm-stress': {
              'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
              'mem-type': faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'kafka-fill': {
              host: faker.random.word(),
              maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
              messageSize: faker.datatype.number({ min: undefined, max: undefined }),
              password: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              reloadCommand: faker.random.word(),
              topic: faker.random.word(),
              username: faker.random.word(),
            },
            'kafka-flood': {
              host: faker.random.word(),
              messageSize: faker.datatype.number({ min: undefined, max: undefined }),
              password: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              threads: faker.datatype.number({ min: undefined, max: undefined }),
              topic: faker.random.word(),
              username: faker.random.word(),
            },
            'kafka-io': {
              configFile: faker.random.word(),
              nonReadable: faker.datatype.boolean(),
              nonWritable: faker.datatype.boolean(),
              topic: faker.random.word(),
            },
            mode: faker.random.word(),
            'network-bandwidth': {
              buffer: faker.datatype.number({ min: undefined, max: undefined }),
              device: faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              limit: faker.datatype.number({ min: undefined, max: undefined }),
              minburst: faker.datatype.number({ min: undefined, max: undefined }),
              peakrate: faker.datatype.number({ min: undefined, max: undefined }),
              rate: faker.random.word(),
            },
            'network-corrupt': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-delay': {
              'accept-tcp-flags': faker.random.word(),
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              jitter: faker.random.word(),
              latency: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-dns': {
              'dns-domain-name': faker.random.word(),
              'dns-ip': faker.random.word(),
              'dns-server': faker.random.word(),
            },
            'network-down': { device: faker.random.word(), duration: faker.random.word() },
            'network-duplicate': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-flood': {
              duration: faker.random.word(),
              'ip-address': faker.random.word(),
              parallel: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.random.word(),
              rate: faker.random.word(),
            },
            'network-loss': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-partition': {
              'accept-tcp-flags': faker.random.word(),
              device: faker.random.word(),
              direction: faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
            },
            process: {
              process: faker.random.word(),
              recoverCmd: faker.random.word(),
              signal: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'redis-cacheLimit': {
              addr: faker.random.word(),
              cacheSize: faker.random.word(),
              password: faker.random.word(),
              percent: faker.random.word(),
            },
            'redis-expiration': {
              addr: faker.random.word(),
              expiration: faker.random.word(),
              key: faker.random.word(),
              option: faker.random.word(),
              password: faker.random.word(),
            },
            'redis-penetration': {
              addr: faker.random.word(),
              password: faker.random.word(),
              requestNum: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'redis-restart': {
              addr: faker.random.word(),
              conf: faker.random.word(),
              flushConfig: faker.datatype.boolean(),
              password: faker.random.word(),
              redisPath: faker.datatype.boolean(),
            },
            'redis-stop': {
              addr: faker.random.word(),
              conf: faker.random.word(),
              flushConfig: faker.datatype.boolean(),
              password: faker.random.word(),
              redisPath: faker.datatype.boolean(),
            },
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jg004vv5di7n5bg9x8: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jg004wv5dibnic6d12: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jg004xv5didspqe6s7: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              physicalMachines: {
                clfp8d9jh004yv5di35cj81wt: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            'stress-cpu': {
              load: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'stress-mem': {
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              size: faker.random.word(),
            },
            user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
            value: faker.random.word(),
            vm: { 'vm-name': faker.random.word() },
          },
          podChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jh004zv5di77pldmaj: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jh0050v5di3h35euif: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jh0051v5dibxbvhycy: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jh0052v5dihvqc00zm: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jh0053v5di2ibb4d2u: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          schedule: faker.random.word(),
          startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          stressChaos: {
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jh0054v5didsfe4kvk: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jh0055v5dih88chlqh: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jh0056v5di58sjbk04: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jh0057v5di0jiifk1v: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jh0058v5di7nj4gehc: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            stressngStressors: faker.random.word(),
            stressors: {
              cpu: {
                load: faker.datatype.number({ min: undefined, max: undefined }),
                options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                workers: faker.datatype.number({ min: undefined, max: undefined }),
              },
              memory: {
                oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
                options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                size: faker.random.word(),
                workers: faker.datatype.number({ min: undefined, max: undefined }),
              },
            },
            value: faker.random.word(),
          },
          timeChaos: {
            clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                clfp8d9jh0059v5di6swcc5ln: faker.random.word(),
              },
              fieldSelectors: {
                clfp8d9jh005av5dig7e2afpu: faker.random.word(),
              },
              labelSelectors: {
                clfp8d9jh005bv5di4zjk273p: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              nodeSelectors: {
                clfp8d9jh005cv5di1idmeght: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
              pods: {
                clfp8d9jh005dv5dib6rl01nh: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => faker.random.word()),
              },
            },
            timeOffset: faker.random.word(),
            value: faker.random.word(),
          },
          type: faker.random.word(),
        },
        statusCheck: {
          duration: faker.random.word(),
          failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
          http: {
            body: faker.random.word(),
            criteria: { statusCode: faker.random.word() },
            headers: {
              clfp8d9jh005ev5die7in20yv: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
            method: faker.random.word(),
            url: faker.random.word(),
          },
          intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          mode: faker.random.word(),
          recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
          successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
          timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          type: faker.random.word(),
        },
        stressChaos: {
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jh005fv5didpoh6m27: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jh005gv5di49cf9boy: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jh005hv5dicmao0qb3: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jh005iv5di1qho9vwd: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jh005jv5di87l9gy2z: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          stressngStressors: faker.random.word(),
          stressors: {
            cpu: {
              load: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
            memory: {
              oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              size: faker.random.word(),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
          value: faker.random.word(),
        },
        task: {
          container: {
            args: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            env: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              name: faker.random.word(),
              value: faker.random.word(),
              valueFrom: {
                configMapKeyRef: {
                  key: faker.random.word(),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                resourceFieldRef: {
                  containerName: faker.random.word(),
                  divisor: { Format: faker.random.word() },
                  resource: faker.random.word(),
                },
                secretKeyRef: {
                  key: faker.random.word(),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
              },
            })),
            envFrom: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              configMapRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
              prefix: faker.random.word(),
              secretRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
            })),
            image: faker.random.word(),
            imagePullPolicy: faker.random.word(),
            lifecycle: {
              postStart: {
                exec: {
                  command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word()
                  ),
                },
                httpGet: {
                  host: faker.random.word(),
                  httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({ name: faker.random.word(), value: faker.random.word() })
                  ),
                  path: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                  scheme: faker.random.word(),
                },
                tcpSocket: {
                  host: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                },
              },
              preStop: {
                exec: {
                  command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word()
                  ),
                },
                httpGet: {
                  host: faker.random.word(),
                  httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({ name: faker.random.word(), value: faker.random.word() })
                  ),
                  path: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                  scheme: faker.random.word(),
                },
                tcpSocket: {
                  host: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                },
              },
            },
            livenessProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() })
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            name: faker.random.word(),
            ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              containerPort: faker.datatype.number({ min: undefined, max: undefined }),
              hostIP: faker.random.word(),
              hostPort: faker.datatype.number({ min: undefined, max: undefined }),
              name: faker.random.word(),
              protocol: faker.random.word(),
            })),
            readinessProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() })
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            resources: {
              claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                name: faker.random.word(),
              })),
              limits: {
                clfp8d9ji005kv5di1qx17h2h: { Format: faker.random.word() },
              },
              requests: {
                clfp8d9ji005lv5di4qwp47gh: { Format: faker.random.word() },
              },
            },
            securityContext: {
              allowPrivilegeEscalation: faker.datatype.boolean(),
              capabilities: {
                add: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
                drop: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              privileged: faker.datatype.boolean(),
              procMount: faker.random.word(),
              readOnlyRootFilesystem: faker.datatype.boolean(),
              runAsGroup: faker.datatype.number({ min: undefined, max: undefined }),
              runAsNonRoot: faker.datatype.boolean(),
              runAsUser: faker.datatype.number({ min: undefined, max: undefined }),
              seLinuxOptions: {
                level: faker.random.word(),
                role: faker.random.word(),
                type: faker.random.word(),
                user: faker.random.word(),
              },
              seccompProfile: { localhostProfile: faker.random.word(), type: faker.random.word() },
              windowsOptions: {
                gmsaCredentialSpec: faker.random.word(),
                gmsaCredentialSpecName: faker.random.word(),
                hostProcess: faker.datatype.boolean(),
                runAsUserName: faker.random.word(),
              },
            },
            startupProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word()
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() })
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            stdin: faker.datatype.boolean(),
            stdinOnce: faker.datatype.boolean(),
            terminationMessagePath: faker.random.word(),
            terminationMessagePolicy: faker.random.word(),
            tty: faker.datatype.boolean(),
            volumeDevices: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ devicePath: faker.random.word(), name: faker.random.word() })
            ),
            volumeMounts: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({
                mountPath: faker.random.word(),
                mountPropagation: faker.random.word(),
                name: faker.random.word(),
                readOnly: faker.datatype.boolean(),
                subPath: faker.random.word(),
                subPathExpr: faker.random.word(),
              })
            ),
            workingDir: faker.random.word(),
          },
          volumes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            awsElasticBlockStore: {
              fsType: faker.random.word(),
              partition: faker.datatype.number({ min: undefined, max: undefined }),
              readOnly: faker.datatype.boolean(),
              volumeID: faker.random.word(),
            },
            azureDisk: {
              cachingMode: faker.random.word(),
              diskName: faker.random.word(),
              diskURI: faker.random.word(),
              fsType: faker.random.word(),
              kind: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            azureFile: {
              readOnly: faker.datatype.boolean(),
              secretName: faker.random.word(),
              shareName: faker.random.word(),
            },
            cephfs: {
              monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              path: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretFile: faker.random.word(),
              secretRef: { name: faker.random.word() },
              user: faker.random.word(),
            },
            cinder: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              volumeID: faker.random.word(),
            },
            configMap: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                key: faker.random.word(),
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
              })),
              name: faker.random.word(),
              optional: faker.datatype.boolean(),
            },
            csi: {
              driver: faker.random.word(),
              fsType: faker.random.word(),
              nodePublishSecretRef: { name: faker.random.word() },
              readOnly: faker.datatype.boolean(),
              volumeAttributes: {
                clfp8d9ji005mv5dicmkt77nd: faker.random.word(),
              },
            },
            downwardAPI: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
                resourceFieldRef: {
                  containerName: faker.random.word(),
                  divisor: { Format: faker.random.word() },
                  resource: faker.random.word(),
                },
              })),
            },
            emptyDir: { medium: faker.random.word(), sizeLimit: { Format: faker.random.word() } },
            ephemeral: {
              volumeClaimTemplate: {
                annotations: {
                  clfp8d9ji005nv5difz975qt0: faker.random.word(),
                },
                creationTimestamp: faker.random.word(),
                deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
                deletionTimestamp: faker.random.word(),
                finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.random.word()
                ),
                generateName: faker.random.word(),
                generation: faker.datatype.number({ min: undefined, max: undefined }),
                labels: {
                  clfp8d9jj005ov5die0h931sw: faker.random.word(),
                },
                managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({
                    apiVersion: faker.random.word(),
                    fieldsType: faker.random.word(),
                    fieldsV1: {},
                    manager: faker.random.word(),
                    operation: faker.random.word(),
                    subresource: faker.random.word(),
                    time: faker.random.word(),
                  })
                ),
                name: faker.random.word(),
                namespace: faker.random.word(),
                ownerReferences: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1
                ).map(() => ({
                  apiVersion: faker.random.word(),
                  blockOwnerDeletion: faker.datatype.boolean(),
                  controller: faker.datatype.boolean(),
                  kind: faker.random.word(),
                  name: faker.random.word(),
                  uid: faker.random.word(),
                })),
                resourceVersion: faker.random.word(),
                selfLink: faker.random.word(),
                uid: faker.random.word(),
              },
            },
            fc: {
              fsType: faker.random.word(),
              lun: faker.datatype.number({ min: undefined, max: undefined }),
              readOnly: faker.datatype.boolean(),
              targetWWNs: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              wwids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
            },
            flexVolume: {
              driver: faker.random.word(),
              fsType: faker.random.word(),
              options: {
                clfp8d9jj005pv5dieutp33c3: faker.random.word(),
              },
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
            },
            flocker: { datasetName: faker.random.word(), datasetUUID: faker.random.word() },
            gcePersistentDisk: {
              fsType: faker.random.word(),
              partition: faker.datatype.number({ min: undefined, max: undefined }),
              pdName: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            gitRepo: { directory: faker.random.word(), repository: faker.random.word(), revision: faker.random.word() },
            glusterfs: {
              endpoints: faker.random.word(),
              path: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            hostPath: { path: faker.random.word(), type: faker.random.word() },
            iscsi: {
              chapAuthDiscovery: faker.datatype.boolean(),
              chapAuthSession: faker.datatype.boolean(),
              fsType: faker.random.word(),
              initiatorName: faker.random.word(),
              iqn: faker.random.word(),
              iscsiInterface: faker.random.word(),
              lun: faker.datatype.number({ min: undefined, max: undefined }),
              portals: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              targetPortal: faker.random.word(),
            },
            name: faker.random.word(),
            nfs: { path: faker.random.word(), readOnly: faker.datatype.boolean(), server: faker.random.word() },
            persistentVolumeClaim: { claimName: faker.random.word(), readOnly: faker.datatype.boolean() },
            photonPersistentDisk: { fsType: faker.random.word(), pdID: faker.random.word() },
            portworxVolume: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              volumeID: faker.random.word(),
            },
            projected: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              sources: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                configMap: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      key: faker.random.word(),
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                    })
                  ),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                downwardAPI: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                      resourceFieldRef: {
                        containerName: faker.random.word(),
                        divisor: { Format: faker.random.word() },
                        resource: faker.random.word(),
                      },
                    })
                  ),
                },
                secret: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      key: faker.random.word(),
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                    })
                  ),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                serviceAccountToken: {
                  audience: faker.random.word(),
                  expirationSeconds: faker.datatype.number({ min: undefined, max: undefined }),
                  path: faker.random.word(),
                },
              })),
            },
            quobyte: {
              group: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              registry: faker.random.word(),
              tenant: faker.random.word(),
              user: faker.random.word(),
              volume: faker.random.word(),
            },
            rbd: {
              fsType: faker.random.word(),
              image: faker.random.word(),
              keyring: faker.random.word(),
              monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word()
              ),
              pool: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              user: faker.random.word(),
            },
            scaleIO: {
              fsType: faker.random.word(),
              gateway: faker.random.word(),
              protectionDomain: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              sslEnabled: faker.datatype.boolean(),
              storageMode: faker.random.word(),
              storagePool: faker.random.word(),
              system: faker.random.word(),
              volumeName: faker.random.word(),
            },
            secret: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                key: faker.random.word(),
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
              })),
              optional: faker.datatype.boolean(),
              secretName: faker.random.word(),
            },
            storageos: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              volumeName: faker.random.word(),
              volumeNamespace: faker.random.word(),
            },
            vsphereVolume: {
              fsType: faker.random.word(),
              storagePolicyID: faker.random.word(),
              storagePolicyName: faker.random.word(),
              volumePath: faker.random.word(),
            },
          })),
        },
        templateType: faker.random.word(),
        timeChaos: {
          clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              clfp8d9jk005qv5di34j8c9pd: faker.random.word(),
            },
            fieldSelectors: {
              clfp8d9jk005rv5di4q5w9cr8: faker.random.word(),
            },
            labelSelectors: {
              clfp8d9jk005sv5di90rs9bcb: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            nodeSelectors: {
              clfp8d9jk005tv5dibc8eft7p: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word()
            ),
            pods: {
              clfp8d9jk005uv5di9jmt7qes: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1
              ).map(() => faker.random.word()),
            },
          },
          timeOffset: faker.random.word(),
          value: faker.random.word(),
        },
      })),
    },
  },
  status: {
    active: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      apiVersion: faker.random.word(),
      fieldPath: faker.random.word(),
      kind: faker.random.word(),
      name: faker.random.word(),
      namespace: faker.random.word(),
      resourceVersion: faker.random.word(),
      uid: faker.random.word(),
    })),
    time: faker.random.word(),
  },
  uid: faker.random.word(),
})

export const getDeleteSchedulesUidMock = () => ({ status: faker.random.word() })

export const getGetSchedulesUidMock = () => ({
  created_at: faker.random.word(),
  experiment_uids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word()
  ),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9jm005vv5di9ymkht49: faker.random.word(),
      },
      labels: {
        clfp8d9jm005wv5di8m1zgrxv: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  uid: faker.random.word(),
})

export const getPutSchedulesPauseUidMock = () => ({ status: faker.random.word() })

export const getPutSchedulesStartUidMock = () => ({ status: faker.random.word() })

export const getGetTemplatesStatuschecksMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    description: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostTemplatesStatuschecksMock = () => ({
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfp8d9jo005xv5di8pgx6uhg: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
})

export const getDeleteTemplatesStatuschecksStatuscheckMock = () => ({ status: faker.random.word() })

export const getGetTemplatesStatuschecksStatuscheckMock = () => ({
  created_at: faker.random.word(),
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfp8d9jp005yv5dihw6c32wy: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
  uid: faker.random.word(),
})

export const getPutTemplatesStatuschecksStatuscheckMock = () => ({
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfp8d9jp005zv5di73a3ehx1: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
})

export const getGetWorkflowsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    end_time: faker.random.word(),
    entry: faker.random.word(),
    finish_time: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostWorkflowsMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9jq0060v5dic6seg5ea: faker.random.word(),
      },
      labels: {
        clfp8d9jq0061v5di5zsgax87: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() })
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getDeleteWorkflowsUidMock = () => ({ status: faker.random.word() })

export const getGetWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9jr0062v5diezph2yko: faker.random.word(),
      },
      labels: {
        clfp8d9jr0063v5dics022gmz: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() })
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getPutWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        clfp8d9jr0064v5di9riu0uti: faker.random.word(),
      },
      labels: {
        clfp8d9jr0065v5di53k6dabk: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() })
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getPostWorkflowsParseTaskHttpMock = () => ({
  body: faker.random.word(),
  followLocation: faker.datatype.boolean(),
  header: {
    clfp8d9js0066v5dicvfac03q: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
      () => faker.random.word()
    ),
  },
  jsonContent: faker.datatype.boolean(),
  method: faker.random.word(),
  name: faker.random.word(),
  url: faker.random.word(),
})

export const getPostWorkflowsRenderTaskHttpMock = () => ({
  abortWithStatusCheck: faker.datatype.boolean(),
  awsChaos: {
    action: faker.random.word(),
    awsRegion: faker.random.word(),
    deviceName: faker.random.word(),
    duration: faker.random.word(),
    ec2Instance: faker.random.word(),
    endpoint: faker.random.word(),
    remoteCluster: faker.random.word(),
    secretName: faker.random.word(),
    volumeID: faker.random.word(),
  },
  azureChaos: {
    action: faker.random.word(),
    diskName: faker.random.word(),
    duration: faker.random.word(),
    lun: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    resourceGroupName: faker.random.word(),
    secretName: faker.random.word(),
    subscriptionID: faker.random.word(),
    vmName: faker.random.word(),
  },
  blockChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9js0067v5di221e3q0p: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9js0068v5dig7af6l1a: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9js0069v5di6cx4hild: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9js006av5di5bp2gbjc: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9js006bv5di6q4bhcb7: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
    volumeName: faker.random.word(),
  },
  children: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word()
  ),
  conditionalBranches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    expression: faker.random.word(),
    target: faker.random.word(),
  })),
  deadline: faker.random.word(),
  dnsChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9js006cv5dicje6gjfd: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jt006dv5dic5v4drzx: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jt006ev5di0h80dwwp: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jt006fv5di366lfh6b: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jt006gv5di4iyh5lqj: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  gcpChaos: {
    action: faker.random.word(),
    deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    instance: faker.random.word(),
    project: faker.random.word(),
    remoteCluster: faker.random.word(),
    secretName: faker.random.word(),
    zone: faker.random.word(),
  },
  httpChaos: {
    abort: faker.datatype.boolean(),
    code: faker.datatype.number({ min: undefined, max: undefined }),
    delay: faker.random.word(),
    duration: faker.random.word(),
    method: faker.random.word(),
    mode: faker.random.word(),
    patch: {
      body: { type: faker.random.word(), value: faker.random.word() },
      headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        )
      ),
      queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        )
      ),
    },
    path: faker.random.word(),
    port: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    replace: {
      body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined })
      ),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      headers: {
        clfp8d9jt006hv5dib5yi3b4v: faker.random.word(),
      },
      method: faker.random.word(),
      path: faker.random.word(),
      queries: {
        clfp8d9jt006iv5di6oemdvkv: faker.random.word(),
      },
    },
    request_headers: {
      clfp8d9jt006jv5diegy7coad: faker.random.word(),
    },
    response_headers: {
      clfp8d9jt006kv5dib4lz95wy: faker.random.word(),
    },
    selector: {
      annotationSelectors: {
        clfp8d9jt006lv5di5w838ued: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jt006mv5dibd5yf6nn: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jt006nv5dihhca1tc3: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jt006ov5dibdwm5e22: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jt006pv5di49mueih7: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    target: faker.random.word(),
    tls: {
      caName: faker.random.word(),
      certName: faker.random.word(),
      keyName: faker.random.word(),
      secretName: faker.random.word(),
      secretNamespace: faker.random.word(),
    },
    value: faker.random.word(),
  },
  ioChaos: {
    action: faker.random.word(),
    attr: {
      atime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      blocks: faker.datatype.number({ min: undefined, max: undefined }),
      ctime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      gid: faker.datatype.number({ min: undefined, max: undefined }),
      ino: faker.datatype.number({ min: undefined, max: undefined }),
      kind: faker.random.word(),
      mtime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      nlink: faker.datatype.number({ min: undefined, max: undefined }),
      perm: faker.datatype.number({ min: undefined, max: undefined }),
      rdev: faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.datatype.number({ min: undefined, max: undefined }),
      uid: faker.datatype.number({ min: undefined, max: undefined }),
    },
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    delay: faker.random.word(),
    duration: faker.random.word(),
    errno: faker.datatype.number({ min: undefined, max: undefined }),
    methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    mistake: {
      filling: faker.random.word(),
      maxLength: faker.datatype.number({ min: undefined, max: undefined }),
      maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
    },
    mode: faker.random.word(),
    path: faker.random.word(),
    percent: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9jt006qv5digzhs9q1t: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jt006rv5dic8j6cl2i: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jt006sv5di5nenf61t: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jt006tv5di3q3v9tii: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jt006uv5di3wqm2p81: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
    volumePath: faker.random.word(),
  },
  jvmChaos: {
    action: faker.random.word(),
    class: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
    database: faker.random.word(),
    duration: faker.random.word(),
    exception: faker.random.word(),
    latency: faker.datatype.number({ min: undefined, max: undefined }),
    memType: faker.random.word(),
    method: faker.random.word(),
    mode: faker.random.word(),
    mysqlConnectorVersion: faker.random.word(),
    name: faker.random.word(),
    pid: faker.datatype.number({ min: undefined, max: undefined }),
    port: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    ruleData: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9jt006vv5didfo69ek4: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jt006wv5di1xvgba44: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jt006xv5dia8ey4yks: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jt006yv5di41lw5dzr: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jt006zv5di8ujbczds: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    sqlType: faker.random.word(),
    table: faker.random.word(),
    value: faker.random.word(),
  },
  kernelChaos: {
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    failKernRequest: {
      callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        funcname: faker.random.word(),
        parameters: faker.random.word(),
        predicate: faker.random.word(),
      })),
      failtype: faker.datatype.number({ min: undefined, max: undefined }),
      headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      probability: faker.datatype.number({ min: undefined, max: undefined }),
      times: faker.datatype.number({ min: undefined, max: undefined }),
    },
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9jt0070v5di1gk775w9: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jt0071v5di45ke1vvg: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jt0072v5didtzkfg21: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jt0073v5di6pkd08p8: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jt0074v5di3krabmgh: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  name: faker.random.word(),
  networkChaos: {
    action: faker.random.word(),
    bandwidth: {
      buffer: faker.datatype.number({ min: undefined, max: undefined }),
      limit: faker.datatype.number({ min: undefined, max: undefined }),
      minburst: faker.datatype.number({ min: undefined, max: undefined }),
      peakrate: faker.datatype.number({ min: undefined, max: undefined }),
      rate: faker.random.word(),
    },
    corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
    delay: {
      correlation: faker.random.word(),
      jitter: faker.random.word(),
      latency: faker.random.word(),
      reorder: {
        correlation: faker.random.word(),
        gap: faker.datatype.number({ min: undefined, max: undefined }),
        reorder: faker.random.word(),
      },
    },
    device: faker.random.word(),
    direction: faker.random.word(),
    duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
    duration: faker.random.word(),
    externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    loss: { correlation: faker.random.word(), loss: faker.random.word() },
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9jt0075v5didcfa6lqv: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jt0076v5dihs8k84j0: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jt0077v5di5f9edh79: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jt0078v5difzco7dnw: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jt0079v5dig73g9c55: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    target: {
      mode: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jt007av5didddj3u73: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jt007bv5di7ydq28zk: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jt007cv5di4aqt0t32: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jt007dv5di3gpo5hqk: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jt007ev5di4cngcsq8: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    targetDevice: faker.random.word(),
    value: faker.random.word(),
  },
  physicalmachineChaos: {
    action: faker.random.word(),
    address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    clock: {
      'clock-ids-slice': faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      'time-offset': faker.random.word(),
    },
    'disk-fill': {
      'fill-by-fallocate': faker.datatype.boolean(),
      path: faker.random.word(),
      size: faker.random.word(),
    },
    'disk-read-payload': {
      path: faker.random.word(),
      'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.random.word(),
    },
    'disk-write-payload': {
      path: faker.random.word(),
      'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.random.word(),
    },
    duration: faker.random.word(),
    'file-append': {
      count: faker.datatype.number({ min: undefined, max: undefined }),
      data: faker.random.word(),
      'file-name': faker.random.word(),
    },
    'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
    'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
    'file-modify': {
      'file-name': faker.random.word(),
      privilege: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
    'file-replace': {
      'dest-string': faker.random.word(),
      'file-name': faker.random.word(),
      line: faker.datatype.number({ min: undefined, max: undefined }),
      'origin-string': faker.random.word(),
    },
    'http-abort': {
      code: faker.random.word(),
      method: faker.random.word(),
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined })
      ),
      target: faker.random.word(),
    },
    'http-config': { file_path: faker.random.word() },
    'http-delay': {
      code: faker.random.word(),
      delay: faker.random.word(),
      method: faker.random.word(),
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined })
      ),
      target: faker.random.word(),
    },
    'http-request': {
      count: faker.datatype.number({ min: undefined, max: undefined }),
      'enable-conn-pool': faker.datatype.boolean(),
      url: faker.random.word(),
    },
    'jvm-exception': {
      class: faker.random.word(),
      exception: faker.random.word(),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-gc': {
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-latency': {
      class: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-mysql': {
      database: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      mysqlConnectorVersion: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      sqlType: faker.random.word(),
      table: faker.random.word(),
    },
    'jvm-return': {
      class: faker.random.word(),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      value: faker.random.word(),
    },
    'jvm-rule-data': {
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      'rule-data': faker.random.word(),
    },
    'jvm-stress': {
      'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
      'mem-type': faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'kafka-fill': {
      host: faker.random.word(),
      maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
      messageSize: faker.datatype.number({ min: undefined, max: undefined }),
      password: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      reloadCommand: faker.random.word(),
      topic: faker.random.word(),
      username: faker.random.word(),
    },
    'kafka-flood': {
      host: faker.random.word(),
      messageSize: faker.datatype.number({ min: undefined, max: undefined }),
      password: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      threads: faker.datatype.number({ min: undefined, max: undefined }),
      topic: faker.random.word(),
      username: faker.random.word(),
    },
    'kafka-io': {
      configFile: faker.random.word(),
      nonReadable: faker.datatype.boolean(),
      nonWritable: faker.datatype.boolean(),
      topic: faker.random.word(),
    },
    mode: faker.random.word(),
    'network-bandwidth': {
      buffer: faker.datatype.number({ min: undefined, max: undefined }),
      device: faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      limit: faker.datatype.number({ min: undefined, max: undefined }),
      minburst: faker.datatype.number({ min: undefined, max: undefined }),
      peakrate: faker.datatype.number({ min: undefined, max: undefined }),
      rate: faker.random.word(),
    },
    'network-corrupt': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-delay': {
      'accept-tcp-flags': faker.random.word(),
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      jitter: faker.random.word(),
      latency: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-dns': {
      'dns-domain-name': faker.random.word(),
      'dns-ip': faker.random.word(),
      'dns-server': faker.random.word(),
    },
    'network-down': { device: faker.random.word(), duration: faker.random.word() },
    'network-duplicate': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-flood': {
      duration: faker.random.word(),
      'ip-address': faker.random.word(),
      parallel: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.random.word(),
      rate: faker.random.word(),
    },
    'network-loss': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-partition': {
      'accept-tcp-flags': faker.random.word(),
      device: faker.random.word(),
      direction: faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
    },
    process: {
      process: faker.random.word(),
      recoverCmd: faker.random.word(),
      signal: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'redis-cacheLimit': {
      addr: faker.random.word(),
      cacheSize: faker.random.word(),
      password: faker.random.word(),
      percent: faker.random.word(),
    },
    'redis-expiration': {
      addr: faker.random.word(),
      expiration: faker.random.word(),
      key: faker.random.word(),
      option: faker.random.word(),
      password: faker.random.word(),
    },
    'redis-penetration': {
      addr: faker.random.word(),
      password: faker.random.word(),
      requestNum: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'redis-restart': {
      addr: faker.random.word(),
      conf: faker.random.word(),
      flushConfig: faker.datatype.boolean(),
      password: faker.random.word(),
      redisPath: faker.datatype.boolean(),
    },
    'redis-stop': {
      addr: faker.random.word(),
      conf: faker.random.word(),
      flushConfig: faker.datatype.boolean(),
      password: faker.random.word(),
      redisPath: faker.datatype.boolean(),
    },
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9ju007fv5di0vq7en0o: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9ju007gv5dihc2397n5: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9ju007hv5di5xby2ydn: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      physicalMachines: {
        clfp8d9ju007iv5diey44gtxi: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    'stress-cpu': {
      load: faker.datatype.number({ min: undefined, max: undefined }),
      options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      workers: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'stress-mem': {
      options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      size: faker.random.word(),
    },
    user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
    value: faker.random.word(),
    vm: { 'vm-name': faker.random.word() },
  },
  podChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9ju007jv5di3bbn8siu: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9ju007kv5di7bpbcmsf: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9ju007lv5dibeoldi35: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9ju007mv5di72bk4euy: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9ju007nv5di7bbv1is0: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  schedule: {
    awsChaos: {
      action: faker.random.word(),
      awsRegion: faker.random.word(),
      deviceName: faker.random.word(),
      duration: faker.random.word(),
      ec2Instance: faker.random.word(),
      endpoint: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      volumeID: faker.random.word(),
    },
    azureChaos: {
      action: faker.random.word(),
      diskName: faker.random.word(),
      duration: faker.random.word(),
      lun: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      resourceGroupName: faker.random.word(),
      secretName: faker.random.word(),
      subscriptionID: faker.random.word(),
      vmName: faker.random.word(),
    },
    blockChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9ju007ov5di2o3y1hjh: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9ju007pv5didh0mhe65: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9ju007qv5dih159a1nb: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9ju007rv5diahmt5n4y: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9ju007sv5di02xrcmpw: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumeName: faker.random.word(),
    },
    concurrencyPolicy: faker.random.word(),
    dnsChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9ju007tv5di1tc43wdk: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9ju007uv5dihnwmey5o: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9ju007vv5dibi2i16l0: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9ju007wv5didoup5nur: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jv007xv5diepp61zq7: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    gcpChaos: {
      action: faker.random.word(),
      deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      instance: faker.random.word(),
      project: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      zone: faker.random.word(),
    },
    historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
    httpChaos: {
      abort: faker.datatype.boolean(),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      delay: faker.random.word(),
      duration: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      patch: {
        body: { type: faker.random.word(), value: faker.random.word() },
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
        queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          )
        ),
      },
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      replace: {
        body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        code: faker.datatype.number({ min: undefined, max: undefined }),
        headers: {
          clfp8d9jv007yv5die5hz6yr4: faker.random.word(),
        },
        method: faker.random.word(),
        path: faker.random.word(),
        queries: {
          clfp8d9jv007zv5di0l9hhiht: faker.random.word(),
        },
      },
      request_headers: {
        clfp8d9jv0080v5diaqggbuhq: faker.random.word(),
      },
      response_headers: {
        clfp8d9jv0081v5dibmkf6awu: faker.random.word(),
      },
      selector: {
        annotationSelectors: {
          clfp8d9jv0082v5die8ns65vj: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jv0083v5didr5bedfr: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jv0084v5diaw3d3bax: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jv0085v5did8nedjlz: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jv0086v5di9v8d0f05: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: faker.random.word(),
      tls: {
        caName: faker.random.word(),
        certName: faker.random.word(),
        keyName: faker.random.word(),
        secretName: faker.random.word(),
        secretNamespace: faker.random.word(),
      },
      value: faker.random.word(),
    },
    ioChaos: {
      action: faker.random.word(),
      attr: {
        atime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        blocks: faker.datatype.number({ min: undefined, max: undefined }),
        ctime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        gid: faker.datatype.number({ min: undefined, max: undefined }),
        ino: faker.datatype.number({ min: undefined, max: undefined }),
        kind: faker.random.word(),
        mtime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        nlink: faker.datatype.number({ min: undefined, max: undefined }),
        perm: faker.datatype.number({ min: undefined, max: undefined }),
        rdev: faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.datatype.number({ min: undefined, max: undefined }),
        uid: faker.datatype.number({ min: undefined, max: undefined }),
      },
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      delay: faker.random.word(),
      duration: faker.random.word(),
      errno: faker.datatype.number({ min: undefined, max: undefined }),
      methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      mistake: {
        filling: faker.random.word(),
        maxLength: faker.datatype.number({ min: undefined, max: undefined }),
        maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      path: faker.random.word(),
      percent: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jv0087v5di5cns9jfp: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jv0088v5digpwnftaw: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jv0089v5di38lec6wo: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jv008av5di93g3aakj: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jv008bv5di7f3bgc2p: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumePath: faker.random.word(),
    },
    jvmChaos: {
      action: faker.random.word(),
      class: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
      database: faker.random.word(),
      duration: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      memType: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      mysqlConnectorVersion: faker.random.word(),
      name: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      ruleData: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jv008cv5di342cht6o: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jv008dv5didppwfi3b: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jv008ev5dicw5penij: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jv008fv5digdgl4ayn: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jv008gv5dierydgi7m: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      sqlType: faker.random.word(),
      table: faker.random.word(),
      value: faker.random.word(),
    },
    kernelChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      failKernRequest: {
        callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          funcname: faker.random.word(),
          parameters: faker.random.word(),
          predicate: faker.random.word(),
        })),
        failtype: faker.datatype.number({ min: undefined, max: undefined }),
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        probability: faker.datatype.number({ min: undefined, max: undefined }),
        times: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jv008hv5di09k95572: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jv008iv5difmbfhymy: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jv008jv5dictjq0ffy: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jv008kv5difw6n8e5e: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jv008lv5difwa20zzn: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    networkChaos: {
      action: faker.random.word(),
      bandwidth: {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
      delay: {
        correlation: faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        reorder: {
          correlation: faker.random.word(),
          gap: faker.datatype.number({ min: undefined, max: undefined }),
          reorder: faker.random.word(),
        },
      },
      device: faker.random.word(),
      direction: faker.random.word(),
      duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
      duration: faker.random.word(),
      externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      loss: { correlation: faker.random.word(), loss: faker.random.word() },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jv008mv5di1kqa7sb6: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jv008nv5di91bg2xtr: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jv008ov5di9dq9ek3i: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jv008pv5di6t3n1zid: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jv008qv5di7ioy0udy: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      target: {
        mode: faker.random.word(),
        selector: {
          annotationSelectors: {
            clfp8d9jv008rv5didbs12dke: faker.random.word(),
          },
          fieldSelectors: {
            clfp8d9jv008sv5di53zc8lt6: faker.random.word(),
          },
          labelSelectors: {
            clfp8d9jv008tv5di4bwra2uo: faker.random.word(),
          },
          namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          nodeSelectors: {
            clfp8d9jv008uv5di04or9lct: faker.random.word(),
          },
          nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => faker.random.word()
          ),
          pods: {
            clfp8d9jv008vv5di8kn185wg: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.random.word()),
          },
        },
        value: faker.random.word(),
      },
      targetDevice: faker.random.word(),
      value: faker.random.word(),
    },
    physicalmachineChaos: {
      action: faker.random.word(),
      address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      clock: {
        'clock-ids-slice': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        'time-offset': faker.random.word(),
      },
      'disk-fill': {
        'fill-by-fallocate': faker.datatype.boolean(),
        path: faker.random.word(),
        size: faker.random.word(),
      },
      'disk-read-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      'disk-write-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      duration: faker.random.word(),
      'file-append': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        data: faker.random.word(),
        'file-name': faker.random.word(),
      },
      'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-modify': {
        'file-name': faker.random.word(),
        privilege: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
      'file-replace': {
        'dest-string': faker.random.word(),
        'file-name': faker.random.word(),
        line: faker.datatype.number({ min: undefined, max: undefined }),
        'origin-string': faker.random.word(),
      },
      'http-abort': {
        code: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-config': { file_path: faker.random.word() },
      'http-delay': {
        code: faker.random.word(),
        delay: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined })
        ),
        target: faker.random.word(),
      },
      'http-request': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        'enable-conn-pool': faker.datatype.boolean(),
        url: faker.random.word(),
      },
      'jvm-exception': {
        class: faker.random.word(),
        exception: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-gc': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-latency': {
        class: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-mysql': {
        database: faker.random.word(),
        exception: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        mysqlConnectorVersion: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        sqlType: faker.random.word(),
        table: faker.random.word(),
      },
      'jvm-return': {
        class: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        value: faker.random.word(),
      },
      'jvm-rule-data': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        'rule-data': faker.random.word(),
      },
      'jvm-stress': {
        'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
        'mem-type': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'kafka-fill': {
        host: faker.random.word(),
        maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        reloadCommand: faker.random.word(),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-flood': {
        host: faker.random.word(),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        threads: faker.datatype.number({ min: undefined, max: undefined }),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-io': {
        configFile: faker.random.word(),
        nonReadable: faker.datatype.boolean(),
        nonWritable: faker.datatype.boolean(),
        topic: faker.random.word(),
      },
      mode: faker.random.word(),
      'network-bandwidth': {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        device: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      'network-corrupt': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-delay': {
        'accept-tcp-flags': faker.random.word(),
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-dns': {
        'dns-domain-name': faker.random.word(),
        'dns-ip': faker.random.word(),
        'dns-server': faker.random.word(),
      },
      'network-down': { device: faker.random.word(), duration: faker.random.word() },
      'network-duplicate': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-flood': {
        duration: faker.random.word(),
        'ip-address': faker.random.word(),
        parallel: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.random.word(),
        rate: faker.random.word(),
      },
      'network-loss': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-partition': {
        'accept-tcp-flags': faker.random.word(),
        device: faker.random.word(),
        direction: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
      },
      process: {
        process: faker.random.word(),
        recoverCmd: faker.random.word(),
        signal: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-cacheLimit': {
        addr: faker.random.word(),
        cacheSize: faker.random.word(),
        password: faker.random.word(),
        percent: faker.random.word(),
      },
      'redis-expiration': {
        addr: faker.random.word(),
        expiration: faker.random.word(),
        key: faker.random.word(),
        option: faker.random.word(),
        password: faker.random.word(),
      },
      'redis-penetration': {
        addr: faker.random.word(),
        password: faker.random.word(),
        requestNum: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-restart': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      'redis-stop': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jw008wv5di7nzof32m: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jw008xv5dih2g35h7o: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jw008yv5dihhowbyl8: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        physicalMachines: {
          clfp8d9jw008zv5di3qd4g5jt: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      'stress-cpu': {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'stress-mem': {
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        size: faker.random.word(),
      },
      user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
      value: faker.random.word(),
      vm: { 'vm-name': faker.random.word() },
    },
    podChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jw0090v5di0clnfm4t: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jw0091v5di9ngr7801: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jw0092v5dicuqj7yi2: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jw0093v5dia7xf7lf8: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jw0094v5di3cttc4vh: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    schedule: faker.random.word(),
    startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    stressChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jw0095v5dih3uc65e3: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jw0096v5diezml7z4p: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jw0097v5dibcgf3l4f: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jw0098v5di7dap51b2: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jw0099v5dicrui84bp: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      stressngStressors: faker.random.word(),
      stressors: {
        cpu: {
          load: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
        memory: {
          oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          size: faker.random.word(),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
      },
      value: faker.random.word(),
    },
    timeChaos: {
      clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          clfp8d9jw009av5dic642cd0f: faker.random.word(),
        },
        fieldSelectors: {
          clfp8d9jw009bv5dihsggg5k9: faker.random.word(),
        },
        labelSelectors: {
          clfp8d9jw009cv5di0s5sgv7r: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        nodeSelectors: {
          clfp8d9jw009dv5diesja0pjt: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pods: {
          clfp8d9jw009ev5di0tfx2p26: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.random.word()),
        },
      },
      timeOffset: faker.random.word(),
      value: faker.random.word(),
    },
    type: faker.random.word(),
  },
  statusCheck: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        clfp8d9jw009fv5di5xl0dc5x: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
  stressChaos: {
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9jw009gv5dib7y39h69: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jw009hv5di1g9m3v36: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jw009iv5di9tis0myi: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jw009jv5di2163h5u2: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jx009kv5difj7a4vrq: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    stressngStressors: faker.random.word(),
    stressors: {
      cpu: {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      memory: {
        oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        size: faker.random.word(),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
    },
    value: faker.random.word(),
  },
  task: {
    container: {
      args: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      env: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        value: faker.random.word(),
        valueFrom: {
          configMapKeyRef: { key: faker.random.word(), name: faker.random.word(), optional: faker.datatype.boolean() },
          fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
          resourceFieldRef: {
            containerName: faker.random.word(),
            divisor: { Format: faker.random.word() },
            resource: faker.random.word(),
          },
          secretKeyRef: { key: faker.random.word(), name: faker.random.word(), optional: faker.datatype.boolean() },
        },
      })),
      envFrom: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        configMapRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
        prefix: faker.random.word(),
        secretRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
      })),
      image: faker.random.word(),
      imagePullPolicy: faker.random.word(),
      lifecycle: {
        postStart: {
          exec: {
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
          },
          httpGet: {
            host: faker.random.word(),
            httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ name: faker.random.word(), value: faker.random.word() })
            ),
            path: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
            scheme: faker.random.word(),
          },
          tcpSocket: {
            host: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
        },
        preStop: {
          exec: {
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
          },
          httpGet: {
            host: faker.random.word(),
            httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ name: faker.random.word(), value: faker.random.word() })
            ),
            path: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
            scheme: faker.random.word(),
          },
          tcpSocket: {
            host: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
        },
      },
      livenessProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      name: faker.random.word(),
      ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        containerPort: faker.datatype.number({ min: undefined, max: undefined }),
        hostIP: faker.random.word(),
        hostPort: faker.datatype.number({ min: undefined, max: undefined }),
        name: faker.random.word(),
        protocol: faker.random.word(),
      })),
      readinessProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      resources: {
        claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          name: faker.random.word(),
        })),
        limits: {
          clfp8d9jx009lv5difcwraz30: { Format: faker.random.word() },
        },
        requests: {
          clfp8d9jx009mv5dibhtd2tla: { Format: faker.random.word() },
        },
      },
      securityContext: {
        allowPrivilegeEscalation: faker.datatype.boolean(),
        capabilities: {
          add: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          drop: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        privileged: faker.datatype.boolean(),
        procMount: faker.random.word(),
        readOnlyRootFilesystem: faker.datatype.boolean(),
        runAsGroup: faker.datatype.number({ min: undefined, max: undefined }),
        runAsNonRoot: faker.datatype.boolean(),
        runAsUser: faker.datatype.number({ min: undefined, max: undefined }),
        seLinuxOptions: {
          level: faker.random.word(),
          role: faker.random.word(),
          type: faker.random.word(),
          user: faker.random.word(),
        },
        seccompProfile: { localhostProfile: faker.random.word(), type: faker.random.word() },
        windowsOptions: {
          gmsaCredentialSpec: faker.random.word(),
          gmsaCredentialSpecName: faker.random.word(),
          hostProcess: faker.datatype.boolean(),
          runAsUserName: faker.random.word(),
        },
      },
      startupProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      stdin: faker.datatype.boolean(),
      stdinOnce: faker.datatype.boolean(),
      terminationMessagePath: faker.random.word(),
      terminationMessagePolicy: faker.random.word(),
      tty: faker.datatype.boolean(),
      volumeDevices: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        devicePath: faker.random.word(),
        name: faker.random.word(),
      })),
      volumeMounts: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        mountPath: faker.random.word(),
        mountPropagation: faker.random.word(),
        name: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        subPath: faker.random.word(),
        subPathExpr: faker.random.word(),
      })),
      workingDir: faker.random.word(),
    },
    volumes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      awsElasticBlockStore: {
        fsType: faker.random.word(),
        partition: faker.datatype.number({ min: undefined, max: undefined }),
        readOnly: faker.datatype.boolean(),
        volumeID: faker.random.word(),
      },
      azureDisk: {
        cachingMode: faker.random.word(),
        diskName: faker.random.word(),
        diskURI: faker.random.word(),
        fsType: faker.random.word(),
        kind: faker.random.word(),
        readOnly: faker.datatype.boolean(),
      },
      azureFile: {
        readOnly: faker.datatype.boolean(),
        secretName: faker.random.word(),
        shareName: faker.random.word(),
      },
      cephfs: {
        monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        path: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretFile: faker.random.word(),
        secretRef: { name: faker.random.word() },
        user: faker.random.word(),
      },
      cinder: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        volumeID: faker.random.word(),
      },
      configMap: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          key: faker.random.word(),
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
        })),
        name: faker.random.word(),
        optional: faker.datatype.boolean(),
      },
      csi: {
        driver: faker.random.word(),
        fsType: faker.random.word(),
        nodePublishSecretRef: { name: faker.random.word() },
        readOnly: faker.datatype.boolean(),
        volumeAttributes: {
          clfp8d9jx009nv5di1xyl7zd5: faker.random.word(),
        },
      },
      downwardAPI: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
          resourceFieldRef: {
            containerName: faker.random.word(),
            divisor: { Format: faker.random.word() },
            resource: faker.random.word(),
          },
        })),
      },
      emptyDir: { medium: faker.random.word(), sizeLimit: { Format: faker.random.word() } },
      ephemeral: {
        volumeClaimTemplate: {
          annotations: {
            clfp8d9jy009ov5di4jntb0kk: faker.random.word(),
          },
          creationTimestamp: faker.random.word(),
          deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          deletionTimestamp: faker.random.word(),
          finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word()
          ),
          generateName: faker.random.word(),
          generation: faker.datatype.number({ min: undefined, max: undefined }),
          labels: {
            clfp8d9jy009pv5dihvhp46kf: faker.random.word(),
          },
          managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              apiVersion: faker.random.word(),
              fieldsType: faker.random.word(),
              fieldsV1: {},
              manager: faker.random.word(),
              operation: faker.random.word(),
              subresource: faker.random.word(),
              time: faker.random.word(),
            })
          ),
          name: faker.random.word(),
          namespace: faker.random.word(),
          ownerReferences: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              apiVersion: faker.random.word(),
              blockOwnerDeletion: faker.datatype.boolean(),
              controller: faker.datatype.boolean(),
              kind: faker.random.word(),
              name: faker.random.word(),
              uid: faker.random.word(),
            })
          ),
          resourceVersion: faker.random.word(),
          selfLink: faker.random.word(),
          spec: {
            accessModes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word()
            ),
            dataSource: { apiGroup: faker.random.word(), kind: faker.random.word(), name: faker.random.word() },
            dataSourceRef: {
              apiGroup: faker.random.word(),
              kind: faker.random.word(),
              name: faker.random.word(),
              namespace: faker.random.word(),
            },
            resources: {
              claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                name: faker.random.word(),
              })),
              limits: {
                clfp8d9jy009qv5di8l0r3jhd: { Format: faker.random.word() },
              },
              requests: {
                clfp8d9jy009rv5di5nl6ewp4: { Format: faker.random.word() },
              },
            },
            selector: {
              matchExpressions: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  key: faker.random.word(),
                  operator: faker.random.word(),
                  values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word()
                  ),
                })
              ),
              matchLabels: {
                clfp8d9jy009sv5difd3bg3pu: faker.random.word(),
              },
            },
            storageClassName: faker.random.word(),
            volumeMode: faker.random.word(),
            volumeName: faker.random.word(),
          },
          uid: faker.random.word(),
        },
      },
      fc: {
        fsType: faker.random.word(),
        lun: faker.datatype.number({ min: undefined, max: undefined }),
        readOnly: faker.datatype.boolean(),
        targetWWNs: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        wwids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
      },
      flexVolume: {
        driver: faker.random.word(),
        fsType: faker.random.word(),
        options: {
          clfp8d9jy009tv5di5ur7c7kh: faker.random.word(),
        },
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
      },
      flocker: { datasetName: faker.random.word(), datasetUUID: faker.random.word() },
      gcePersistentDisk: {
        fsType: faker.random.word(),
        partition: faker.datatype.number({ min: undefined, max: undefined }),
        pdName: faker.random.word(),
        readOnly: faker.datatype.boolean(),
      },
      gitRepo: { directory: faker.random.word(), repository: faker.random.word(), revision: faker.random.word() },
      glusterfs: { endpoints: faker.random.word(), path: faker.random.word(), readOnly: faker.datatype.boolean() },
      hostPath: { path: faker.random.word(), type: faker.random.word() },
      iscsi: {
        chapAuthDiscovery: faker.datatype.boolean(),
        chapAuthSession: faker.datatype.boolean(),
        fsType: faker.random.word(),
        initiatorName: faker.random.word(),
        iqn: faker.random.word(),
        iscsiInterface: faker.random.word(),
        lun: faker.datatype.number({ min: undefined, max: undefined }),
        portals: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        targetPortal: faker.random.word(),
      },
      name: faker.random.word(),
      nfs: { path: faker.random.word(), readOnly: faker.datatype.boolean(), server: faker.random.word() },
      persistentVolumeClaim: { claimName: faker.random.word(), readOnly: faker.datatype.boolean() },
      photonPersistentDisk: { fsType: faker.random.word(), pdID: faker.random.word() },
      portworxVolume: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        volumeID: faker.random.word(),
      },
      projected: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        sources: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          configMap: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              key: faker.random.word(),
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
            })),
            name: faker.random.word(),
            optional: faker.datatype.boolean(),
          },
          downwardAPI: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
              resourceFieldRef: {
                containerName: faker.random.word(),
                divisor: { Format: faker.random.word() },
                resource: faker.random.word(),
              },
            })),
          },
          secret: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              key: faker.random.word(),
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
            })),
            name: faker.random.word(),
            optional: faker.datatype.boolean(),
          },
          serviceAccountToken: {
            audience: faker.random.word(),
            expirationSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            path: faker.random.word(),
          },
        })),
      },
      quobyte: {
        group: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        registry: faker.random.word(),
        tenant: faker.random.word(),
        user: faker.random.word(),
        volume: faker.random.word(),
      },
      rbd: {
        fsType: faker.random.word(),
        image: faker.random.word(),
        keyring: faker.random.word(),
        monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word()
        ),
        pool: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        user: faker.random.word(),
      },
      scaleIO: {
        fsType: faker.random.word(),
        gateway: faker.random.word(),
        protectionDomain: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        sslEnabled: faker.datatype.boolean(),
        storageMode: faker.random.word(),
        storagePool: faker.random.word(),
        system: faker.random.word(),
        volumeName: faker.random.word(),
      },
      secret: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          key: faker.random.word(),
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
        })),
        optional: faker.datatype.boolean(),
        secretName: faker.random.word(),
      },
      storageos: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        volumeName: faker.random.word(),
        volumeNamespace: faker.random.word(),
      },
      vsphereVolume: {
        fsType: faker.random.word(),
        storagePolicyID: faker.random.word(),
        storagePolicyName: faker.random.word(),
        volumePath: faker.random.word(),
      },
    })),
  },
  templateType: faker.random.word(),
  timeChaos: {
    clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word()
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        clfp8d9jy009uv5dictndbnnh: faker.random.word(),
      },
      fieldSelectors: {
        clfp8d9jy009vv5di5wwwey4z: faker.random.word(),
      },
      labelSelectors: {
        clfp8d9jy009wv5dift8e7y2w: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      nodeSelectors: {
        clfp8d9jy009xv5diepnl9y1i: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word()
      ),
      pods: {
        clfp8d9jy009yv5di9ebo6st3: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.random.word()),
      },
    },
    timeOffset: faker.random.word(),
    value: faker.random.word(),
  },
})

export const getPostWorkflowsValidateTaskHttpMock = () => faker.datatype.boolean()

export const getChaosMeshDashboardAPIMSW = () => [
  rest.delete('*/archives', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesMock()))
  }),
  rest.get('*/archives', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesMock()))
  }),
  rest.delete('*/archives/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesUidMock()))
  }),
  rest.get('*/archives/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesUidMock()))
  }),
  rest.delete('*/archives/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesSchedulesMock()))
  }),
  rest.get('*/archives/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesSchedulesMock()))
  }),
  rest.delete('*/archives/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesSchedulesUidMock()))
  }),
  rest.get('*/archives/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesSchedulesUidMock()))
  }),
  rest.delete('*/archives/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesWorkflowsMock()))
  }),
  rest.get('*/archives/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesWorkflowsMock()))
  }),
  rest.delete('*/archives/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesWorkflowsUidMock()))
  }),
  rest.get('*/archives/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesWorkflowsUidMock()))
  }),
  rest.get('*/common/annotations', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonAnnotationsMock()))
  }),
  rest.get('*/common/chaos-available-namespaces', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonChaosAvailableNamespacesMock()))
  }),
  rest.get('*/common/config', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonConfigMock()))
  }),
  rest.get('*/common/kinds', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonKindsMock()))
  }),
  rest.get('*/common/labels', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonLabelsMock()))
  }),
  rest.get('*/common/namespaces', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonNamespacesMock()))
  }),
  rest.get('*/common/physicalmachine-annotations', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonPhysicalmachineAnnotationsMock()))
  }),
  rest.get('*/common/physicalmachine-labels', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonPhysicalmachineLabelsMock()))
  }),
  rest.post('*/common/physicalmachines', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostCommonPhysicalmachinesMock()))
  }),
  rest.post('*/common/pods', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostCommonPodsMock()))
  }),
  rest.get('*/common/rbac-config', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonRbacConfigMock()))
  }),
  rest.get('*/events', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsMock()))
  }),
  rest.get('*/events/:id', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsIdMock()))
  }),
  rest.get('*/events/workflow/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsWorkflowUidMock()))
  }),
  rest.delete('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteExperimentsMock()))
  }),
  rest.get('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsMock()))
  }),
  rest.post('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostExperimentsMock()))
  }),
  rest.delete('*/experiments/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteExperimentsUidMock()))
  }),
  rest.get('*/experiments/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsUidMock()))
  }),
  rest.put('*/experiments/pause/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutExperimentsPauseUidMock()))
  }),
  rest.put('*/experiments/start/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutExperimentsStartUidMock()))
  }),
  rest.get('*/experiments/state', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsStateMock()))
  }),
  rest.delete('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteSchedulesMock()))
  }),
  rest.get('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetSchedulesMock()))
  }),
  rest.post('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostSchedulesMock()))
  }),
  rest.delete('*/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteSchedulesUidMock()))
  }),
  rest.get('*/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetSchedulesUidMock()))
  }),
  rest.put('*/schedules/pause/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutSchedulesPauseUidMock()))
  }),
  rest.put('*/schedules/start/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutSchedulesStartUidMock()))
  }),
  rest.get('*/templates/statuschecks', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetTemplatesStatuschecksMock()))
  }),
  rest.post('*/templates/statuschecks', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostTemplatesStatuschecksMock()))
  }),
  rest.delete('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(
      ctx.delay(0),
      ctx.status(200, 'Mocked status'),
      ctx.json(getDeleteTemplatesStatuschecksStatuscheckMock())
    )
  }),
  rest.get('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetTemplatesStatuschecksStatuscheckMock()))
  }),
  rest.put('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutTemplatesStatuschecksStatuscheckMock()))
  }),
  rest.get('*/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetWorkflowsMock()))
  }),
  rest.post('*/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsMock()))
  }),
  rest.delete('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteWorkflowsUidMock()))
  }),
  rest.get('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetWorkflowsUidMock()))
  }),
  rest.put('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutWorkflowsUidMock()))
  }),
  rest.post('*/workflows/parse-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsParseTaskHttpMock()))
  }),
  rest.post('*/workflows/render-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsRenderTaskHttpMock()))
  }),
  rest.post('*/workflows/validate-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsValidateTaskHttpMock()))
  }),
]
